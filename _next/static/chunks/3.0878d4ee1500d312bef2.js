(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{709:function(s){s.exports={"/etc/2019-11-14-letsencrypt-public-ca":{path:"/etc/2019-11-14-letsencrypt-public-ca",content:'<h2 id="1letsencrypt">1. Letsencrypt 클라이언트 다운받기</h2>\n<p>다운로드 받고자하는 경로에서 다음 명령어를 실행한다.</p>\n<pre><code class="hljs">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/letsencrypt/letsencrypt\n</code></pre>\n<h2 id="2">2. 의존성 다운로드 받기</h2>\n<p>다운로드 받은 후 <code>letsencrypt</code> 디렉토리에서 다음 명령어를 실행한다.</p>\n<pre><code class="hljs"><span class="hljs-string">./letsencrypt-auto</span> <span class="hljs-params">--help</span>\n</code></pre>\n<h2 id="3">3. 인증서 발급받기</h2>\n<p><code>letsencrypt</code> 디렉토리에서 다음 명령어를 실행한다.</p>\n<p><em>주의: 반드시 80포트가 비어있는 상태에서 해야한다.</em></p>\n<pre><code class="hljs">./letsencrypt-auto certonly <span class="hljs-comment">--standalone -n -m &lt;your email&gt; --agree-tos -d &lt;your domain: www.example.com&gt;</span>\n</code></pre>\n<p><strong><code>&lt;your email&gt;</code>에 담당자 메일 주소를 작성한다.</strong></p>\n<p><strong><code>&lt;your domain&gt;</code>에 구매한 도메인 주소를 작성한다.</strong></p>\n<p><img src="/static/images/etc/letsencrypt_create_ca.png" alt="letsencrypt_create_ca" /></p>\n<h2 id="4pempkcs12">4. pem -&gt; pkcs12 변환</h2>\n<p><strong>root 계정으로 접근 <code>sudu su</code></strong></p>\n<p>그 다음 발급된 인증서 경로로 이동한다.</p>\n<pre><code class="hljs">cd <span class="hljs-meta-keyword">/etc/</span>letsencrypt<span class="hljs-meta-keyword">/live/</span><span class="hljs-params">&lt;your domain&gt;</span>\n</code></pre>\n<p>그런 다음 아래 openssl 명령어를 실행한다.</p>\n<pre><code class="hljs">openssl pkcs12 -export -<span class="hljs-keyword">in</span> fullchain<span class="hljs-selector-class">.pem</span> -inkey privkey<span class="hljs-selector-class">.pem</span> -out cert_and_key<span class="hljs-selector-class">.p12</span> -name &lt;project name&gt;\n</code></pre>\n<p><strong><code>&lt;project name&gt;</code>에 프로젝트 이름을 작성한다.</strong></p>\n<p>그럼 비밀번호를 물어보는데 비밀번호를 입력한다.</p>\n<p><img src="/static/images/etc/letsencrypt_create_cert_and_key.png" alt="letsencrypt_create_cert_and_key" /></p>\n<p><strong>비밀번호는 기억하고 있어야한다.</strong></p>\n<h2 id="5pkcs12jks">5. pkcs12 -&gt; jks로 변환</h2>\n<p>keytool을 이용해 jks를 생성한다. 다음 명령어를 실행한다.</p>\n<pre><code class="hljs">keytool -importkeystore -srcstorepass &lt;password&gt; -destkeystore &lt;project name&gt;<span class="hljs-selector-class">.jks</span> -srckeystore cert_and_key<span class="hljs-selector-class">.p12</span> -srcstoretype PKCS12 -storepass &lt;password&gt;\n</code></pre>\n<p><strong><code>&lt;project name&gt;</code>에 프로젝트 이름을 작성한다.</strong></p>\n<p><strong><code>&lt;password&gt;</code> 영역에 pem -> pkcs12 변환했을 때, 입력한 비밀번호로 바꾼다.</strong></p>\n<p><img src="/static/images/etc/letsencrypt_create_jks.png" alt="letsencrypt_create_jks" /></p>\n<p>여기까지 실행되었고 다음과 같이 목록이 보인다면 정상적으로 인증서 발급이 끝났다.</p>\n<p><img src="/static/images/etc/letsencrypt-list.png" alt="letsencrypt-list" /></p>\n<h2 id="6jks">6. JKS 생성 경로</h2>\n<p>생성된 JKS는 다음과 같은 경로에 생성되어 있다.</p>\n<pre><code class="hljs"><span class="hljs-meta-keyword">/etc/</span>letsencrypt<span class="hljs-meta-keyword">/live/</span><span class="hljs-params">&lt;your domain&gt;</span>/<span class="hljs-params">&lt;project name&gt;</span>.jks\n</code></pre>\n<p>이 생성된 JKS를 가지고 Java Keystore에 등록하여 사용하면 된다.</p>\n<h2 id="7">7. 프로젝트 재기동</h2>\n<p>생성된 JKS를 Java Keystore에 등록한 후 프로젝트를 재기동하여 브라우저 URL 입력 왼쪽 부분을 확인하여 CA가 적용되었는지 확인한다.</p>\n<p><strong>정상</strong></p>\n<p><img src="/static/images/etc/letsencrypt-success.png" alt="letsencrypt-success" /></p>',preview:"1. LETSENCRYPT 클라이언트 다운받기\n다운로드 받고자하는 경로에서 다음 명령어를 실행한다.\n\ngit clone https://github.com/letsencrypt/letsencrypt\n\n\n2. 의존성 다운로드 받기\n다운로드 받은 후 letsencrypt 디렉토리에서 다음 명령어를 실행한다.\n\n./letsencrypt-auto --help\n\n\n3...",title:"Letsencrypt로 공인 CA 적용하기",author:"salgum1114",date:"2019-11-14 10:00",tags:"letsencrypt, openssl",cover:"/static/images/covers/letsencrypt.png",next:"/etc/2019-10-22-react-design-editor-1",prev:null},"/etc/2019-10-22-react-design-editor-1":{path:"/etc/2019-10-22-react-design-editor-1",content:'<p>이번에 React Design Editor 프로젝트에 차트를 추가할 수 있도록 업데이트 했다.</p>\n<p>차트는 Canvas로 개발된 Baidu의 Echarts를 사용하였다.</p>\n<p>최초는 Chart.js를 사용하여 Canvas의 Context로 차트를 Fabric.js 내로 직접 렌더링 하려 했으나 Chart.js의 레이아웃 기능 제약에 막혀 Echarts를 선택하게 됐다.</p>\n<p>Chart.js를 사용하려고 했던 배경은 다음과 같다.</p>\n<pre><code class="hljs"><span class="hljs-number">1.</span> Canvas의 Context로 차트를 렌더링한다.\n<span class="hljs-number">2.</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Fabric</span>.</span></span>js의 Custom Object Class에서는 `_render`함수에서 Canvas의 Context를 다룰 수 있다.\n<span class="hljs-number">3.</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Chart</span>.</span></span>js의 옵션이 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Echart</span>.</span></span>js의 사용법보다 쉽다.\n</code></pre>\n<p>처음 개발 단계에서 순조롭게 Chart.js의 인스턴스를 생성할 떄, Fabric.js의 context를 활용하여 차트를 렌더링할 수 있었지만, Chart.js의 레이아웃 옵션에는 width, height를 따로 지정할 수 있는 방법이 없었다.</p>\n<blockquote>\n  <p>Chart.js의 레이아웃 옵션에는 <code>responsive</code> 반응형 옵션만 제공된다.</p>\n</blockquote>\n<p>결국 Chart.js는 포기하고 다양한 차트를 지원하는 Echarts를 React Design Editor 내에 구현된 Element Handler를 통해 구현하게 되었다.</p>\n<blockquote>\n  <p>Echarts의 경우 Canvas의 Context로 직접 다룰 수 있는지에 대한 여부는 확인되지 않았지만, 향후에 발견하게 되다면 변경할 예정이다.</p>\n</blockquote>\n<p>현재 차트 옵션을 통으로 설정하게 되어 있고, 복사 및 붙여 넣기, 크기 조절, 브라우저 반응형을 지원한다.</p>\n<p><img src="/static/images/etc/react-design-editor-chart.png" alt="react-design-editor-chart" /></p>',preview:"이번에 React Design Editor 프로젝트에 차트를 추가할 수 있도록 업데이트 했다.\n\n차트는 Canvas로 개발된 Baidu의 Echarts를 사용하였다.\n\n최초는 Chart.js를 사용하여 Canvas의 Context로 차트를 Fabric.js 내로 직접 렌더링 하려 했으나 Chart.js의\n레이아웃 기능 제약에 막혀 Echarts를 선택하게 ...",title:"[React Design Editor] 차트 추가",author:"salgum1114",date:"2019-10-20 10:09",tags:"react, antd, fabricjs, react-design-editor",cover:"/static/images/covers/react-design-editor.png",next:"/nextjs/2019-05-28-nextjs-static-website-5",prev:"/etc/2019-11-14-letsencrypt-public-ca"},"/nextjs/2019-05-28-nextjs-static-website-5":{path:"/nextjs/2019-05-28-nextjs-static-website-5",content:'<p>이번에는 프로젝트에 <a href="https://material-ui.com/getting-started/installation/">Material UI</a>를 적용하여 레이아웃을 만들어 보고 몇가지 컴포넌트를 사용하여 레이아웃을 만들어보려고 한다.</p>\n<p>먼저 <code>Metarial UI</code>를 사용하기 위해 <code>npm package</code>를 받는다.</p>\n<pre><code class="hljs javascrpt language-javascrpt"><span class="hljs-built_in">npm</span> install --save @material-ui/core @material-ui/icons @material-ui/styles\n</code></pre>\n<p><code>Next.js</code>는 기본적으로 Server Side Rendering 이기 때문에, 단순히 <code>Material UI</code> 컴포넌트를 사용만할 경우 스타일이 정상적으로 먹히지 않는다.\n그렇기 때문에 몇가지 작업을 해줘야 하는데, 일반적인 <strong>Server Rendering</strong>인 경우에는 <a href="https://material-ui.com/guides/server-rendering/">Material Server Rendering</a>을 참고하면 되고 우리는 <code>Next.js</code>를 사용하기 때문에 <a href="https://github.com/mui-org/material-ui/tree/master/examples/nextjs">Material with Next.js</a>를 참고하면 된다.</p>\n<p>기존에 <code>_app.js</code>에 작성된 레이아웃을 바꿔보기 위해 <code>Layout</code> 컴포넌트를 새로 만든다.</p>\n<p><code>components</code> 디렉토리에 <code>Layout.js</code> 파일을 생성하고 다음 코드를 작성한다.</p>\n<p><strong>Layout.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/link\'</span>;\n<span class="hljs-keyword">import</span> {\n    AppBar,\n    IconButton,\n    Toolbar,\n    Typography,\n    Drawer,\n    Divider,\n    List,\n    ListItem,\n    ListItemIcon,\n    ListItemText,\n    Container,\n} <span class="hljs-keyword">from</span> <span class="hljs-string">\'@material-ui/core\'</span>;\n<span class="hljs-keyword">import</span> { Menu, ChevronLeft, Home, Inbox, Mail } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@material-ui/icons\'</span>;\n\n<span class="hljs-keyword">const</span> drawerWidth = <span class="hljs-number">240</span>;\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Layout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n    state = {\n        <span class="hljs-attr">open</span>: <span class="hljs-literal">false</span>,\n    }\n\n    handleDrawerOpen = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-keyword">this</span>.setState({\n            <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,\n        });\n    }\n\n    handleDrawerClose = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-keyword">this</span>.setState({\n            <span class="hljs-attr">open</span>: <span class="hljs-literal">false</span>,\n        });\n    }\n\n    render() {\n        <span class="hljs-keyword">const</span> { children } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">const</span> { open } = <span class="hljs-keyword">this</span>.state;\n        <span class="hljs-keyword">return</span> (\n            &lt;section&gt;\n                &lt;AppBar\n                    position="static"\n                    style={{\n                        width: `calc(100% - ${open ? drawerWidth : 0}px)`,\n                        marginLeft: open ? drawerWidth : 0,\n                        transition: \'all 0.2s\',\n                    }}\n                &gt;\n                    &lt;Toolbar&gt;\n                        &lt;IconButton edge="start" color="inherit" aria-label="Menu" onClick={this.handleDrawerOpen}&gt;\n                            &lt;Menu /&gt;\n                        &lt;/IconButton&gt;\n                        &lt;Typography variant="h6" style={{ flex: 1 }}&gt;\n                            Static Website\n                        &lt;/Typography&gt;\n                    &lt;/Toolbar&gt;\n                &lt;/AppBar&gt;\n                &lt;Drawer variant="persistent" open={open}&gt;\n                    &lt;div style={{ width: drawerWidth }}&gt;\n                        &lt;div style={{ display: \'flex\', justifyContent: \'flex-end\' }}&gt;\n                            &lt;IconButton onClick={this.handleDrawerClose}&gt;\n                                &lt;ChevronLeft /&gt;\n                            &lt;/IconButton&gt;\n                        &lt;/div&gt;\n                        &lt;Divider /&gt;\n                        &lt;List&gt;\n                            &lt;Link href="/"&gt;\n                                &lt;a&gt;\n                                    &lt;ListItem button&gt;\n                                        &lt;ListItemIcon&gt;&lt;Home /&gt;&lt;/ListItemIcon&gt;\n                                        &lt;ListItemText primary="Home"/&gt;\n                                    &lt;/ListItem&gt;\n                                &lt;/a&gt;\n                            &lt;/Link&gt;\n                            &lt;Link href="/post"&gt;\n                                &lt;a&gt;\n                                    &lt;ListItem button&gt;\n                                        &lt;ListItemIcon&gt;&lt;Inbox /&gt;&lt;/ListItemIcon&gt;\n                                        &lt;ListItemText primary="Post"/&gt;\n                                    &lt;/ListItem&gt;\n                                &lt;/a&gt;\n                            &lt;/Link&gt;\n                            &lt;Link href="/about"&gt;\n                                &lt;a&gt;\n                                    &lt;ListItem button&gt;\n                                        &lt;ListItemIcon&gt;&lt;Mail /&gt;&lt;/ListItemIcon&gt;\n                                        &lt;ListItemText primary="About"/&gt;\n                                    &lt;/ListItem&gt;\n                                &lt;/a&gt;\n                            &lt;/Link&gt;\n                        &lt;/List&gt;\n                    &lt;/div&gt;\n                &lt;/Drawer&gt;\n                &lt;Container&gt;\n                    &lt;article style={{\n                        width: `calc(100% - ${open ? drawerWidth : 0}px)`,\n                        marginLeft: open ? drawerWidth : 0,\n                        transition: \'all 0.2s\',\n                        margin: \'16px 0\',\n                    }}&gt;\n                        {children}\n                    &lt;/article&gt;\n                &lt;/Container&gt;\n            &lt;/section&gt;\n        );\n    }\n}\n\nexport default Layout;\n</code></pre>\n<p>그리고나서 <code>app.js</code>에 작성된 레이아웃 코드를 다음과 같이 변경한다.</p>\n<p><strong>app.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> App, { Container } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/app\'</span>;\n<span class="hljs-keyword">import</span> Head <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/head\'</span>;\n<span class="hljs-keyword">import</span> Layout <span class="hljs-keyword">from</span> <span class="hljs-string">\'../components/material/Layout\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{\n    render() {\n        <span class="hljs-keyword">const</span> { Component, ...other } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> (\n            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">Head</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Static Website<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n                <span class="hljs-tag">&lt;/<span class="hljs-name">Head</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">Layout</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...other</span>} /&gt;</span>\n                <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span>\n        );\n    }\n}\n</span></code></pre>\n<p>여기까지 작성 후에 화면을 확인해본다.</p>\n<p><img src="/static/images/nextjs/first-material-ui.png" alt="first-material-ui" /></p>\n<p>하지만 화면을 새로고침해서 보게되면 처음에 설명했다시피 스타일이 적용되지 않았다가 렌더링이 모두 끝난 후 스타일이 적용되는 것을 볼 수 있다.</p>\n<p><img src="/static/images/nextjs/material-client-rendering.gif" alt="material-client-rendering" /></p>\n<p>이 문제를 해결하기 위해 <code>_document.js</code>와 <code>_app.js</code>를 수정한다.</p>\n<p><strong>_document.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Document, { Head, Main, NextScript } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/document\'</span>;\n<span class="hljs-keyword">import</span> { ServerStyleSheets } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@material-ui/styles\'</span>;\n<span class="hljs-keyword">import</span> flush <span class="hljs-keyword">from</span> <span class="hljs-string">\'styled-jsx/server\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootDocument</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Document</span> </span>{\n    <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> getInitialProps(ctx) {\n        <span class="hljs-comment">// Render app and page and get the context of the page with collected side effects.</span>\n        <span class="hljs-keyword">const</span> sheets = <span class="hljs-keyword">new</span> ServerStyleSheets();\n        <span class="hljs-keyword">const</span> originalRenderPage = ctx.renderPage;\n\n        ctx.renderPage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>\n        originalRenderPage({\n            <span class="hljs-attr">enhanceApp</span>: <span class="hljs-function"><span class="hljs-params">App</span> =&gt;</span> props =&gt; sheets.collect(&lt;App {...props} /&gt;),\n        });\n\n        const initialProps = await Document.getInitialProps(ctx);\n\n        return {\n            ...initialProps,\n            // Styles fragment is rendered after the app and page rendering finish.\n            styles: (\n                &lt;React.Fragment&gt;\n                    {sheets.getStyleElement()}\n                    {flush() || null}\n                &lt;/React.Fragment&gt;\n            ),\n        };\n    }\n\n    render() {\n        return (\n            &lt;html&gt;\n                &lt;Head&gt;\n                    &lt;meta charSet="utf-8" /&gt;\n                    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" /&gt;\n                    &lt;meta name="description" content="My First Static Website"/&gt;\n                    &lt;meta name="keywords" content="nextjs,static,website" /&gt;\n                &lt;/Head&gt;\n                &lt;body&gt;\n                    &lt;Main /&gt;\n                    &lt;NextScript /&gt;\n                &lt;/body&gt;\n            &lt;/html&gt;\n        );\n    }\n}\n</code></pre>\n<p><strong>_app.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> App, { Container } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/app\'</span>;\n<span class="hljs-keyword">import</span> Head <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/head\'</span>;\n<span class="hljs-keyword">import</span> CssBaseline <span class="hljs-keyword">from</span> <span class="hljs-string">\'@material-ui/core/CssBaseline\'</span>;\n\n<span class="hljs-keyword">import</span> Layout <span class="hljs-keyword">from</span> <span class="hljs-string">\'../components/material/Layout\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{\n    componentDidMount() {\n        <span class="hljs-comment">// Remove the server-side injected CSS.</span>\n        <span class="hljs-keyword">const</span> jssStyles = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'#jss-server-side\'</span>);\n        <span class="hljs-keyword">if</span> (jssStyles) {\n            jssStyles.parentNode.removeChild(jssStyles);\n        }\n    }\n\n    render() {\n        <span class="hljs-keyword">const</span> { Component, ...other } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> (\n            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">Head</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Static Website<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n                <span class="hljs-tag">&lt;/<span class="hljs-name">Head</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">CssBaseline</span> /&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">Layout</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...other</span>} /&gt;</span>\n                <span class="hljs-tag">&lt;/<span class="hljs-name">Layout</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span>\n        );\n    }\n}\n</span></code></pre>\n<p>다시 화면을 확인해본다.</p>\n<p><img src="/static/images/nextjs/material-server-rendering.gif" alt="material-server-rendering" /></p>\n<p>새로고침을 해도 스타일이 정상적으로 적용되는 것을 확인할 수 있다.</p>\n<p>이렇게해서 <code>Material UI</code> 컴포넌트를 적용해봤고 컴포넌트들을 사용해서 화면을 구성해 나가면 된다.</p>\n<p>다음 글에서는 <code>Ant.Design</code>을 적용하여 Layout을 작성해본다.</p>\n<h3 id="nextjs">Next.js로 정적 웹사이트 만들기 목차</h3>\n<ul>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-06-nextjs-static-website-1/">Next.js로 정적 웹사이트 만들기 - 1. Next.js 구조</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-20-nextjs-static-website-2/">Next.js로 정적 웹사이트 만들기 - 2. 프로젝트 구성</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-21-nextjs-static-website-3/">Next.js로 정적 웹사이트 만들기 - 3. 레이아웃</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-24-nextjs-static-website-4/">Next.js로 정적 웹사이트 만들기 - 4. Routing 사용하기</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-28-nextjs-static-website-5/">Next.js로 정적 웹사이트 만들기 - 5. Material UI 적용하기</a></li>\n</ul>',preview:"이번에는 프로젝트에 Material UI를 적용하여 레이아웃을 만들어 보고 몇가지 컴포넌트를 사용하여 레이아웃을 만들어보려고 한다.\n\n먼저 Metarial UI를 사용하기 위해 npm package를 받는다.\n\nnpm install --save @material-ui/core @material-ui/icons @material-ui/styles\n\n\nNext...",title:"Next.js로 정적 웹사이트 만들기 - 5. Material UI 적용하기",author:"salgum1114",date:"2019-05-28 15:00",tags:"react, nextjs, website",cover:"/static/images/covers/nextjs.png",next:"/nextjs/2019-05-24-nextjs-static-website-4",prev:"/etc/2019-10-22-react-design-editor-1"},"/nextjs/2019-05-24-nextjs-static-website-4":{path:"/nextjs/2019-05-24-nextjs-static-website-4",content:'<p><a href="https://salgum1114.github.io/nextjs/2019-05-21-nextjs-static-website-3/">지난 글</a>에서 <code>index.js</code>와 <code>post.js</code>를 생성했었고 <code>Routing</code>을 사용하지 않고 URL로 직접 접근해서 화면을 확인했었다. 이번 글에서는 <code>Next.js</code>의 <code>Routing</code>을 사용하여 페이지 전환을 해보려고한다.</p>\n<blockquote>\n  <p><a href="https://github.com/zeit/next.js/#routing">Next.js github</a>에 <code>Routing</code>에 대한 설명이 잘 나와있다.</p>\n  <p><code>Next.js</code>에서 <code>Route</code>는 <code>pages</code>디렉토리 경로에 작성한 파일명으로 생성된다. 그렇기 때문에, 파일명도 신경써서 잘 만들어야한다.</p>\n</blockquote>\n<h2 id="aboutjs">about.js 파일 생성</h2>\n<p>Routing 경로를 더 추가하기 위해 <code>pages</code>디렉토리에 <code>about.js</code>파일을 추가하고 다음과 같이 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n}\n</code></pre>\n<p><code>about.js</code>까지 생성하였다면 총 3개의 Routing이 생기게 되었다.</p>\n<h2 id="_appjslink">_app.js에 Link 컴포넌트 추가</h2>\n<p>그런 다음, 공통의 레이아웃이 작성된 <code>_app.js</code>에서 <code>&lt;header&gt;</code>엘리먼트 안에 <code>&lt;Link&gt;</code> 컴포넌트를 추가하여 생성한 <code>Routing</code> 연결해본다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> App, { Container } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/app\'</span>;\n<span class="hljs-keyword">import</span> Head <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/head\'</span>;\n<span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/link\'</span>;\n\n<span class="hljs-keyword">const</span> styles = {\n    <span class="hljs-attr">layout</span>: {\n        <span class="hljs-attr">display</span>: <span class="hljs-string">\'flex\'</span>,\n        <span class="hljs-attr">width</span>: <span class="hljs-string">\'100%\'</span>,\n        <span class="hljs-attr">height</span>: <span class="hljs-string">\'100%\'</span>,\n        <span class="hljs-attr">flexDirection</span>: <span class="hljs-string">\'column\'</span>,\n    },\n    <span class="hljs-attr">header</span>: {\n        <span class="hljs-attr">height</span>: <span class="hljs-number">60</span>,\n    },\n    <span class="hljs-attr">main</span>: {\n        <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>,\n    },\n    <span class="hljs-attr">footer</span>: {\n        <span class="hljs-attr">height</span>: <span class="hljs-number">60</span>,\n    },\n    <span class="hljs-attr">divider</span>: {\n        <span class="hljs-attr">margin</span>: <span class="hljs-string">\'0 8px\'</span>,\n    },\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{\n    render() {\n        <span class="hljs-keyword">const</span> { Component, ...other } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> (\n            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">Head</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Static Website<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n                <span class="hljs-tag">&lt;/<span class="hljs-name">Head</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.layout}</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.header}</span>&gt;</span>\n                        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n                        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.divider}</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n                        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/post"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>Post<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n                        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.divider}</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n                        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/about"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>\n                    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.main}</span>&gt;</span>\n                        <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...other</span>} /&gt;</span>\n                    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.footer}</span>&gt;</span>Footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>\n                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span>\n        );\n    }\n}\n</span></code></pre>\n<p><code>import Link from \'next/link\'</code>로 모듈을 import 해주고 <code>&lt;Link&gt;</code> 컴포넌트에 <code>href</code> Props 값으로 <code>pages</code>디렉토리에서 생성한 파일명을 작성해준다. 마지막으로 <code>&lt;Link&gt;</code>안에는 <code>&lt;a&gt;</code>를 추가해준다.</p>\n<p>여기까지 작성되었다면 다음과 같은 화면이 보일 것이다.</p>\n<p><img src="/static/images/nextjs/first-routing.png" alt="first-routing" /></p>\n<p>한 번씩 눌러본다.</p>\n<p><img src="/static/images/nextjs/first-routing-click.gif" alt="first-routing-click" /></p>\n<h2 id="postjsrouter">post.js에 Router 추가</h2>\n<p>다음으로, <code>&lt;button&gt;</code>엘리먼트 <code>onClick</code>을 이용해서 <code>Routing</code>을 해보는데, 이때 <code>Next.js</code>의 <code>Router</code>를 사용해본다.</p>\n<p>먼저, <code>&lt;Link&gt;</code>와 <code>Router</code>의 큰 차이점은 클라이언트 사이드로 렌더링 하냐 안하냐에 있다.</p>\n<blockquote>\n  <p><code>Router.push</code>를 사용하면 클라이언트 사이드로 렌더링을 한다.</p>\n</blockquote>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/router\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            First post page\n            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> Router.push(\'/\')}&gt;Home<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  \n    );\n}\n</code></pre>\n<p><code>post.js</code>에서 <code>import Router from \'next/router\'</code>로 모듈을 import 해주고 <code>&lt;button&gt;</code>을 추가한 다음 <code>onClick</code> 속성에 <code>Router.push(\'/\')</code>를 추가한다.</p>\n<p>여기까지 작성되었다면 다음처럼 동작한다.</p>\n<p><img src="/static/images/nextjs/first-router-click.gif" alt="first-router-click" /></p>\n<p>마찬가지로 <code>about.js</code>에도 추가해준다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/router\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            About\n            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> Router.push(\'/\')}&gt;Home<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n}\n</code></pre>\n<h2 id="urlparamsquerystring">URL Params(Query String) 전달</h2>\n<p>다음으로 <code>Routing</code>을 할 때, URL로 Parameter를 전달하여 각 페이지에서 전달받은 Parameter를 화면에 처리할 수 있도록 해본다.</p>\n<blockquote>\n  <p><code>Home</code> 버튼을 클릭 했을 때, 어떤 페이지에서 <code>Home</code>으로 돌아왔는지 확인해보는 예제를 작성한다.</p>\n</blockquote>\n<p><code>post.js</code>에서 했던 것처럼 <code>about.js</code>에도 <code>&lt;button&gt;</code>엘리먼트를 추가하고 <code>onClick</code>속성에 <code>Router.push</code>를 추가한다.</p>\n<p>그러고 나서 <code>post.js</code>와 <code>about.js</code>에 작성된 <code>Router.push(\'/\')</code>를 각각 <code>Router.push(\'/?history=post\')</code>와 <code>Router.push(\'/?history=about\')</code>로 변경해준다.</p>\n<p><strong>post.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/router\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            First post page\n            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> Router.push(\'/?history=post\')}&gt;Home<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  \n    );\n}\n</code></pre>\n<p><strong>about.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/router\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            About\n            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> Router.push(\'/?history=about\')}&gt;Home<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n}\n</code></pre>\n<p>이렇게 작성된 페이지에서 <code>Home</code> 버튼을 클릭하여 <code>Home</code>경로로 가게 됐을 경우, URL에는 Query String이 붙게 되었고, <code>index.js</code>에 전달되는 props에 <code>console.log(props)</code>로 로그를 확인해보면 <code>Develop Console</code>에 다음처럼 보이게 된다.</p>\n<p><img src="/static/images/nextjs/first-query-string.png" alt="first-query-string" /></p>\n<p>props에 <code>router</code> 오브젝트가 전달되는데, <code>router</code> 오브젝트 안에서 전달된 <code>query</code>를 확인할 수 있다.</p>\n<p>이것을 활용해서 <code>index.js</code>에서 어떤 페이지로부터 넘어왔는지 확인해본다.</p>\n<p><strong>index.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> styles = {\n    <span class="hljs-attr">from</span>: {\n        <span class="hljs-attr">color</span>: <span class="hljs-string">\'red\'</span>,\n    },\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">const</span> { router } = props;\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            Home\n            {\n                router.query.history ? (\n                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.from}</span>&gt;</span>\n                        From the {router.query.history}\n                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n                ) : null\n            }\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n}\n</code></pre>\n<p>화면을 확인해본다.</p>\n<p><img src="/static/images/nextjs/first-query-string-from.png" alt="first-query-string-from" /></p>\n<h2 id="asurlparams"><strong>as</strong> 속성으로 URL Params 숨기기</h2>\n<p><code>URL Params</code>가 URL에 보이는 것이 맘이 편하지 않다면 <code>Next.js</code>에서는 숨길 수 있는 방법이 있다.</p>\n<p><code>as</code>속성을 이용하는 것인데, <code>&lt;Link href="/?history=post" as="/"&gt;</code>로 사용하거나 <code>Router.push("/?history=post", \'/\')</code>로 사용할 수 있다.</p>\n<p><code>post.js</code>와 <code>about.js</code>에 가서 다음과 같이 바꿔준다.</p>\n<p><strong>post.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/router\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            First post page\n            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> Router.push(\'/?history=post\', \'/\')}&gt;Home<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  \n    );\n}\n</code></pre>\n<p><strong>about.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/router\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            About\n            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> Router.push(\'/?history=about\', \'/\')}&gt;Home<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n}\n</code></pre>\n<p>다시 화면을 확인해본다.</p>\n<p><img src="/static/images/nextjs/first-routing-as.gif" alt="first-routing-as" /></p>\n<p>아까와는 다르게 URL에 <code>Query String</code>이 붙지 않고 <code>history</code>가 전달된 것을 확인할 수 있다.</p>\n<blockquote>\n  <p>하지만 이 방법에서 문제점을 찾으라고 한다면, 새로고침을 했을 때 전달받은 <code>router</code> 오브젝트에 <code>query</code>가 비어있으므로 <code>From the</code>문구가 보이지 않게 된다.</p>\n</blockquote>\n<h2 id="withrouter"><strong>withRouter</strong> 사용</h2>\n<p>다음으로 <code>withRouter</code>를 사용해볼 것인데, 이 녀석은 <code>Router</code>의 <code>HOC</code>로써  컴포넌트에서 <code>router</code> props를 전달받을 수 있도록 해준다.</p>\n<p><code>History</code> 예제를 위해서 root 경로에 <code>components</code> 디렉토리를 만들고 하위에 <code>History.js</code> 파일을 생성한다.</p>\n<p>그런 다음, <code>History.js</code>에는 다음과 같이 작성한다.</p>\n<p><strong>History.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> { withRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/router\'</span>;\n\n<span class="hljs-keyword">const</span> styles = {\n    <span class="hljs-attr">history</span>: {\n        <span class="hljs-attr">color</span>: <span class="hljs-string">\'red\'</span>,\n    },\n};\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">History</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n    render() {\n        <span class="hljs-keyword">const</span> { router } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> router.query.history ? (\n            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.history}</span>&gt;</span>\n                {router.query.history}\n            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n        ) : <span class="hljs-literal">null</span>;\n    }\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withRouter(History);\n</code></pre>\n<p><code>import { withRouter } from \'next/router\'</code>로 모듈을 import 시키고 <code>withRouter(History)</code>로 Component를 감싸게 되면 props로 router를 전달받을 수 있게 된다.</p>\n<p><code>index.js</code>는 다음과 같이 변경한다.</p>\n<p><strong>index.js</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> History <span class="hljs-keyword">from</span> <span class="hljs-string">\'../components/History\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            Home\n            <span class="hljs-tag">&lt;<span class="hljs-name">History</span> /&gt;</span>\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    );\n}\n</code></pre>\n<p>작성한 후에 화면을 확인한다.</p>\n<p><img src="/static/images/nextjs/first-router-history.png" alt="first-router-history" /></p>\n<p><code>index.js</code>에서 <code>&lt;History&gt;</code>로 <code>router</code>를 props으로 전달하지 않지만 <code>&lt;History&gt;</code>컴포넌트에서 <code>HOC</code>로 <code>withRotuer</code>를 사용했기 때문에 props로 <code>router</code>오브젝트를 전달받은 것을 볼 수 있다.</p>\n<p><img src="/static/images/nextjs/first-router-history-log.png" alt="first-router-history-log" /></p>\n<h3 id="nextjs">Next.js로 정적 웹사이트 만들기 목차</h3>\n<ul>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-06-nextjs-static-website-1/">Next.js로 정적 웹사이트 만들기 - 1. Next.js 구조</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-20-nextjs-static-website-2/">Next.js로 정적 웹사이트 만들기 - 2. 프로젝트 구성</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-21-nextjs-static-website-3/">Next.js로 정적 웹사이트 만들기 - 3. 레이아웃</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-24-nextjs-static-website-4/">Next.js로 정적 웹사이트 만들기 - 4. Routing 사용하기</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-28-nextjs-static-website-5/">Next.js로 정적 웹사이트 만들기 - 5. Material UI 적용하기</a></li>\n</ul>',preview:"지난 글에서 index.js와 post.js를 생성했었고 Routing을 사용하지 않고 URL로 직접 접근해서 화면을 확인했었다. 이번 글에서는 \nNext.js의 Routing을 사용하여 페이지 전환을 해보려고한다.\n\n>  Next.js github에 Routing에 대한 설명이 잘 나와있다.\n\nNext.js에서 Route는 pages디렉토리 경로에 작성한...",title:"Next.js로 정적 웹사이트 만들기 - 4. Routing 사용하기",author:"salgum1114",date:"2019-05-24 08:27",tags:"react, nextjs, website",cover:"/static/images/covers/nextjs.png",next:"/nextjs/2019-05-21-nextjs-static-website-3",prev:"/nextjs/2019-05-28-nextjs-static-website-5"},"/nextjs/2019-05-21-nextjs-static-website-3":{path:"/nextjs/2019-05-21-nextjs-static-website-3",content:'<p><a href="https://salgum1114.github.io/nextjs/2019-05-20-nextjs-static-website-2/">이전 글</a>에서 프로젝트 구성을 하여 간단한 화면을 확인했었다.</p>\n<p>이번에는 Next.js에 내장되어 있는 <code>_document.js</code>, <code>_app.js</code>, <code>_error.js</code>를 커스터마이징하여 레이아웃을 새롭게 구성하는 방법을 설명하려고 한다.</p>\n<blockquote>\n  <p>각각에 대한 설명은 <a href="https://salgum1114.github.io/nextjs/2019-05-06-nextjs-static-website-1/">Next.js 구조</a>에서 확인할 수 있다.</p>\n</blockquote>\n<h2 id="_documentjs">_document.js 파일 생성</h2>\n<p><code>_document.js</code>는 Next.js에서 서버 사이드 렌더링이 시작이되는 <code>Document</code> 파일이다.</p>\n<p>즉, <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>를 포함한다고 보면된다.</p>\n<p>그럼 <code>pages</code>디렉토리에 <code>_document.js</code>파일을 생성하고, 다음과 같이 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Document, { Head, Main, NextScript } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/document\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootDocument</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Document</span> </span>{\n    render() {\n        <span class="hljs-keyword">return</span> (\n            &lt;html&gt;\n                &lt;Head&gt;\n                    &lt;meta charSet="utf-8" /&gt;\n                    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" /&gt;\n                    &lt;meta name="description" content="My First Static Website"/&gt;\n                    &lt;meta name="keywords" content="nextjs,static,website" /&gt;\n                    &lt;style global jsx&gt;\n                        {`\n                            html, body, #__next {\n                                height: 100%;\n                                width: 100%;\n                                overflow: hidden;\n                            }\n                        `}\n                    &lt;/style&gt;\n                &lt;/Head&gt;\n                &lt;body&gt;\n                    &lt;Main /&gt;\n                    &lt;NextScript /&gt;\n                &lt;/body&gt;\n            &lt;/html&gt;\n        );\n    }\n}\n</code></pre>\n<p><code>&lt;Head&gt;</code>안에 <code>&lt;script&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;link&gt;</code> 등 리소스 및 Metadata들을 작성해줄 수 있다.</p>\n<h2 id="_appjs">_app.js 파일 생성</h2>\n<p><code>_app.js</code>는 어플리케이션이 시작되는 초기 페이지라고 볼 수 있다. 이 페이지에서는 라우팅을 통해 컴포넌트를 <code>props</code>으로 전달받기 때문에 공통의 레이아웃을 작성하여 모든 화면에서 같은 레이아웃이 나올 수 있도록 작업하거나, <code>ComponentDidCatch</code>와 같은 라이프 사이클을 통해 <code>Error Handling</code>을 할 수 있다.</p>\n<p><code>pages</code>디렉토리에 <code>_app.js</code>파일을 생성하고, 다음과 같이 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> App, { Container } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/app\'</span>;\n<span class="hljs-keyword">import</span> Head <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/head\'</span>;\n<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n\n<span class="hljs-keyword">const</span> styles = {\n    <span class="hljs-attr">layout</span>: {\n        <span class="hljs-attr">display</span>: <span class="hljs-string">\'flex\'</span>,\n        <span class="hljs-attr">width</span>: <span class="hljs-string">\'100%\'</span>,\n        <span class="hljs-attr">height</span>: <span class="hljs-string">\'100%\'</span>,\n        <span class="hljs-attr">flexDirection</span>: <span class="hljs-string">\'column\'</span>,\n    },\n    <span class="hljs-attr">header</span>: {\n        <span class="hljs-attr">height</span>: <span class="hljs-number">60</span>,\n    },\n    <span class="hljs-attr">main</span>: {\n        <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>,\n    },\n    <span class="hljs-attr">footer</span>: {\n        <span class="hljs-attr">height</span>: <span class="hljs-number">60</span>,\n    },\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{\n    render() {\n        <span class="hljs-keyword">const</span> { Component, ...other } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> (\n            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">Head</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Static Website<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n                <span class="hljs-tag">&lt;/<span class="hljs-name">Head</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.layout}</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.header}</span>&gt;</span>Header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.main}</span>&gt;</span>\n                        <span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...other</span>} /&gt;</span>\n                    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>\n                    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.footer}</span>&gt;</span>Footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>\n                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span>\n        );\n    }\n}\n</span></code></pre>\n<p><code>&lt;header&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;footer&gt;</code>로 레이아웃을 만들고 <code>props</code>로 전달 받은 <code>Component</code>를 렌더링한다.</p>\n<p>여기까지 작성한 다음 화면을 확인해본다.</p>\n<p><img src="/static/images/nextjs/first-layout.png" alt="first-layout" /></p>\n<p>Header, Static Website, Footer순으로 화면에 보인다.</p>\n<p>이렇게 해서 <code>pages</code>에 페이지들을 추가하게 되면 Next.js에서는 URL에서 페이지 경로로 접근했을 경우 페이지에 작성된 <code>Component</code>를 전달해주게 되어 공통의 레아이웃으로 화면은 구현할 수 있게 된다.</p>\n<h2 id="_errorjs">_error.js 파일 생성</h2>\n<p>Next.js에서는 <code>pages</code>에 없는 경로로 접근했을 경우, 내장되어 있는 Error 페이지를 보여주게 되어있다.</p>\n<p>마찬가지로 Error 페이지도 새롭게 작성할 수 있다.</p>\n<p><code>pages</code>디렉토리에 <code>_error.js</code>파일을 생성하고 다음과 같이 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n    render() {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">\'Error!\'</span>;\n    }\n}\n</code></pre>\n<p>작성한 후에 현재 경로에 <code>/post</code>를 붙여 URL에 접근해보면 다음과 같은 에러 화면을 확인할 수 있다.</p>\n<p><img src="/static/images/nextjs/first-error-page.png" alt="first-error-page" /></p>\n<p>여기까지 레이아웃을 구성하였다면 <code>pages</code>에 새로운 페이지를 만들어서 확인해본다.</p>\n<h2 id="postjs">post.js 파일 생성</h2>\n<p><code>pages</code>디렉토리에 <code>post.js</code>파일을 생성하고 다음과 같이 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            First post page\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  \n    );\n}\n</code></pre>\n<p><code>post.js</code>를 만들기 전에 <code>/post</code>경로로 접근했을 때는 에러가 났었지만 이제는 <code>First post page</code>라는 문구로 화면에 에러없이 나오는 것을 확인할 수 있다.</p>\n<p><img src="/static/images/nextjs/first-post-page.png" alt="first-post-page" /></p>\n<h3 id="nextjs">Next.js로 정적 웹사이트 만들기 목차</h3>\n<ul>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-06-nextjs-static-website-1/">Next.js로 정적 웹사이트 만들기 - 1. Next.js 구조</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-20-nextjs-static-website-2/">Next.js로 정적 웹사이트 만들기 - 2. 프로젝트 구성</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-21-nextjs-static-website-3/">Next.js로 정적 웹사이트 만들기 - 3. 레이아웃</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-24-nextjs-static-website-4/">Next.js로 정적 웹사이트 만들기 - 4. Routing 사용하기</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-28-nextjs-static-website-5/">Next.js로 정적 웹사이트 만들기 - 5. Material UI 적용하기</a></li>\n</ul>',preview:"이전 글에서 프로젝트 구성을 하여 간단한 화면을 확인했었다.\n\n이번에는 Next.js에 내장되어 있는 _document.js, _app.js, _error.js를 커스터마이징하여 레이아웃을 새롭게 구성하는\n방법을 설명하려고 한다.\n\n>  각각에 대한 설명은 Next.js 구조에서 확인할 수 있다.\n\n\n_DOCUMENT.JS 파일 생성\n_document.js...",title:"Next.js로 정적 웹사이트 만들기 - 3. 레이아웃",author:"salgum1114",date:"2019-05-21 10:00",tags:"react, nextjs, website",cover:"/static/images/covers/nextjs.png",next:"/nextjs/2019-05-20-nextjs-static-website-2",prev:"/nextjs/2019-05-24-nextjs-static-website-4"},"/nextjs/2019-05-20-nextjs-static-website-2":{path:"/nextjs/2019-05-20-nextjs-static-website-2",content:'<p>사실 Next.js는 설명할게 별로 없다. <a href="https://github.com/zeit/next.js/tree/canary/examples">예제들</a>이 너무 잘되어 있기 때문에.. 그렇지만 내 머릿속에서 사라져가기 때문에 기록이라도 남기려고 작성한다.</p>\n<h2 id="1npm">1. npm 프로젝트 생성</h2>\n<p>프로젝트를 구성하기 위해 <code>static-website</code> 디렉토리를 하나 만들고 <code>cd static-website</code>로 가서 <code>npm init</code>으로 npm 프로젝트를 만들자.</p>\n<blockquote>\n  <p>참고로 <code>npm init</code>을 실행하게 되면 여러 입력을 받게 되는데, 나중에 변경할 수 있으니 다 엔터를 치고 넘어간다.</p>\n</blockquote>\n<p><code>npm init</code>이 완료되었으면, <code>static-website</code> 폴더에 <code>package.json</code> 파일이 하나 생성된걸 볼 수 있는데, npm 프로젝트는 이 파일로 시작해서 끝난다고 보면 된다.</p>\n<h2 id="2dependencies">2. dependencies 설치</h2>\n<p>기본적으로 Next.js로 프로젝트를 구성하여 웹 페이지까지 띄우기 위해 필요한 종속성으로는 다음이 필요하다.</p>\n<ul>\n<li>@babel/node // node 파일에서 es6 문법을 사용하기 위해서</li>\n<li>@babel/preset-env // es6 문법을 사용하기 위해서</li>\n<li>next@7.0.2 // <a href="https://salgum1114.github.io/nextjs/2019-05-06-nextjs-static-website-1/">Next.js구조</a>에서 확인 가능</li>\n<li>react</li>\n<li>react-dom</li>\n</ul>\n<p>이 종속성들을 설치해보자.</p>\n<p><code>static-website</code> 경로에서 각 명령어들을 실행한다.</p>\n<p><strong>depenencies</strong></p>\n<p><code>npm install --save react react-dom next@7.0.2 express</code></p>\n<p><strong>devDependecies</strong></p>\n<p><code>npm install --save-dev @babel/node @babel/preset-env</code></p>\n<p>이렇게 <code>npm install</code> 명령어로 종속성들을 설치하고나면 다음과 같이 <code>package.json</code>이 구성된다.</p>\n<blockquote>\n  <p>-dev가 붙은 것과 아닌 것의 차이는 runtime 중에 종속성을 사용하냐 안하냐로 대부분 구분 짓는다.</p>\n</blockquote>\n<pre><code class="hljs javascript language-javascript">{\n  <span class="hljs-string">"name"</span>: <span class="hljs-string">"static-website"</span>,\n  <span class="hljs-string">"version"</span>: <span class="hljs-string">"1.0.0"</span>,\n  <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span>,\n  <span class="hljs-string">"main"</span>: <span class="hljs-string">"index.js"</span>,\n  <span class="hljs-string">"scripts"</span>: {\n    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \\"Error: no test specified\\" &amp;&amp; exit 1"</span>\n  },\n  <span class="hljs-string">"author"</span>: <span class="hljs-string">""</span>,\n  <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>,\n  <span class="hljs-string">"dependencies"</span>: {\n    <span class="hljs-string">"next"</span>: <span class="hljs-string">"^7.0.2"</span>,\n    <span class="hljs-string">"react"</span>: <span class="hljs-string">"^16.8.6"</span>,\n    <span class="hljs-string">"react-dom"</span>: <span class="hljs-string">"^16.8.6"</span>\n  },\n  <span class="hljs-string">"devDependencies"</span>: {\n    <span class="hljs-string">"@babel/node"</span>: <span class="hljs-string">"^7.2.2"</span>,\n    <span class="hljs-string">"@babel/preset-env"</span>: <span class="hljs-string">"^7.4.4"</span>\n  }\n}\n</code></pre>\n<p>여기까지 되었으면 향후에 이 프로젝트가 <code>git</code>에 연결될 수도 있기 때문에,<code>static-website</code> 경로에 <code>.gitignore</code>를 만들어 <code>node_modules</code>와 같은 것들을 제외 시켜준다.</p>\n<p>현재는 <code>node_modules</code>와 <code>package-lock.json</code>만 있으니 두개를 제외시킨다.</p>\n<pre><code class="hljs">node_modules/\npacakge-<span class="hljs-keyword">lock</span>.json\n</code></pre>\n<h2 id="nextconfigjs">next.config.js 생성</h2>\n<p>기본적으로 Next.js는 프로젝트의 루트 경로에 있는 next.config.js를 읽어들이게 된다.</p>\n<p>간단하게 <code>next.config.js</code>를 생성한다. 파일 내용은 다음과 같이 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">module</span>.exports = {};\n</code></pre>\n<blockquote>\n  <p>향후에 플러그인들을 설정에 추가한다.</p>\n</blockquote>\n<h2 id="packagejson">package.json 스크립트 작성</h2>\n<p>Next.js 패키지를 설치하게 되면 다음과 같은 cli를 제공한다.</p>\n<ul>\n<li>next // 내장되어 있는 webpack-dev-server로 기동</li>\n<li>next build // 프로젝트를 빌드하여 .next 폴더를 생성한다.</li>\n<li>next start // 빌드된 .next 폴더를 기준으로 웹 서버를 기동해준다.</li>\n<li>next export // html 파일들로 내보내기를 해준다.</li>\n</ul>\n<blockquote>\n  <p>Next.js에는 webpack 설정이 내장되어 있기 때문에, hot-loader 같은 것들이 기본적으로 동작한다.</p>\n</blockquote>\n<p>다음과 같이 <code>package.json</code>의 <code>scripts</code>에 추가해준다.</p>\n<pre><code class="hljs javascript language-javascript">{\n  <span class="hljs-string">"name"</span>: <span class="hljs-string">"static-website"</span>,\n  <span class="hljs-string">"version"</span>: <span class="hljs-string">"1.0.0"</span>,\n  <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span>,\n  <span class="hljs-string">"main"</span>: <span class="hljs-string">"index.js"</span>,\n  <span class="hljs-string">"scripts"</span>: {\n    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \\"Error: no test specified\\" &amp;&amp; exit 1"</span>,\n    <span class="hljs-string">"dev"</span>: <span class="hljs-string">"next"</span>,\n    <span class="hljs-string">"build"</span>: <span class="hljs-string">"next build"</span>,\n    <span class="hljs-string">"start"</span>: <span class="hljs-string">"next start"</span>,\n    <span class="hljs-string">"export"</span>: <span class="hljs-string">"next export"</span>\n  },\n  <span class="hljs-string">"author"</span>: <span class="hljs-string">""</span>,\n  <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>,\n  <span class="hljs-string">"dependencies"</span>: {\n    <span class="hljs-string">"express"</span>: <span class="hljs-string">"^4.17.0"</span>,\n    <span class="hljs-string">"next"</span>: <span class="hljs-string">"^7.0.2"</span>,\n    <span class="hljs-string">"react"</span>: <span class="hljs-string">"^16.8.6"</span>,\n    <span class="hljs-string">"react-dom"</span>: <span class="hljs-string">"^16.8.6"</span>\n  },\n  <span class="hljs-string">"devDependencies"</span>: {\n    <span class="hljs-string">"@babel/node"</span>: <span class="hljs-string">"^7.2.2"</span>,\n    <span class="hljs-string">"@babel/preset-env"</span>: <span class="hljs-string">"^7.4.4"</span>\n  }\n}\n</code></pre>\n<p>이 상태로 npm run dev로 기동해보면 실패한다. 이유는 <code>pages</code> 폴더가 없어서 그렇다.</p>\n<h2 id="pagesindexjs">pages 폴더 및 index.js 파일 생성</h2>\n<p><code>static-website</code> 경로에 <code>pages</code> 폴더를 생성하고 그 하위에 <code>index.js</code> 파일을 생성한다.</p>\n<p><code>index.js</code> 에는 다음과 같이 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (props) =&gt; {\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n            static webiste\n        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>\n    )\n}\n</code></pre>\n<p>그리고 나서 <code>npm run dev</code> 를 다시 실행해본다.</p>\n<blockquote>\n  <p>next의 기본 포트는 3000이고 변경하고자 하면 next -p <포트 번호> 를 붙이면 된다.</p>\n</blockquote>\n<p>localhost:3000으로 접속하여 화면을 확인하면 static website를 출력하는 화면이 나온다.</p>\n<p><img src="/static/images/nextjs/first-page.png" alt="first-page" /></p>\n<p><code>pages</code>에 <code>index.js</code>를 작성하게 되면 <code>index.js</code>는 루트 컨텍스트로 인식하게 된다. 따라서 나중에 Home과 같은 화면은 <code>index.js</code>에서 컴포넌트를 구현하면 된다.</p>\n<h3 id="nextjs">Next.js로 정적 웹사이트 만들기 목차</h3>\n<ul>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-06-nextjs-static-website-1/">Next.js로 정적 웹사이트 만들기 - 1. Next.js 구조</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-20-nextjs-static-website-2/">Next.js로 정적 웹사이트 만들기 - 2. 프로젝트 구성</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-21-nextjs-static-website-3/">Next.js로 정적 웹사이트 만들기 - 3. 레이아웃</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-24-nextjs-static-website-4/">Next.js로 정적 웹사이트 만들기 - 4. Routing 사용하기</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-28-nextjs-static-website-5/">Next.js로 정적 웹사이트 만들기 - 5. Material UI 적용하기</a></li>\n</ul>',preview:"사실 Next.js는 설명할게 별로 없다. 예제들이 너무 잘되어 있기 때문에.. 그렇지만 내 머릿속에서 사라져가기 때문에 기록이라도 남기려고\n작성한다.\n\n1. NPM 프로젝트 생성\n프로젝트를 구성하기 위해 static-website 디렉토리를 하나 만들고 cd static-website로 가서 npm init으로 npm\n프로젝트를 만들자.\n\n>  참고로 n...",title:"Next.js로 정적 웹사이트 만들기 - 2. 프로젝트 구성",author:"salgum1114",date:"2019-05-20 12:43",tags:"react, nextjs, website",cover:"/static/images/covers/nextjs.png",next:"/etc/2019-05-20-using-openssl-in-windows",prev:"/nextjs/2019-05-21-nextjs-static-website-3"},"/etc/2019-05-20-using-openssl-in-windows":{path:"/etc/2019-05-20-using-openssl-in-windows",content:'<p>회사에서 MQTT를 SSL/TLS로 테스트해야 하는 경우가 생겼는데, 기존에 나와있는 <a href="https://mosquitto.org/">Eclipse Mosquitto</a>로 하려다가 이왕 하는 김에 Javascrpt로 MQTT Broker랑 Client (Pub, Sub)를 직접 구현해보기로 했다.</p>\n<p>전체적으로 MQTT Broker와 Client를 구현하기 위한 라이브러리들은 다음과 같다.</p>\n<ul>\n<li><a href="https://github.com/mcollina/mosca">Mosca</a> (MQTT Broker) </li>\n<li><a href="https://github.com/mqttjs/MQTT.js">MQTT.js</a> (MQTT Client)</li>\n</ul>\n<p>두개의 라이브러리를 받고 예제를 각 라이브러리들의 github에서 사용법을 찾아보면 된다.</p>\n<h2 id="moscaserverts">Mosca 예제 (server.ts)</h2>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> mosca <span class="hljs-keyword">from</span> <span class="hljs-string">\'mosca\'</span>;\n\n<span class="hljs-keyword">import</span> { moscaSettings } <span class="hljs-keyword">from</span> <span class="hljs-string">\'./options\'</span>;\n\n<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> mosca.Server(moscaSettings, () =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Mosca server is up and running\'</span>);\n});\n\nserver.on(<span class="hljs-string">\'clientConnected\'</span>, (client: mosca.Client) =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Client connected\'</span>, client.id, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());\n});\n\nserver.on(<span class="hljs-string">\'clientDisconnected\'</span>, (client: mosca.Client) =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Client Disconnected:\'</span>, client.id, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());\n});\n\nserver.on(<span class="hljs-string">\'published\'</span>, (packet: mosca.Packet, client?: mosca.Client, callback?: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>) =&gt; {\n    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">\'Published\'</span>, packet.payload, client &amp;&amp; client.id, callback);\n});\n</code></pre>\n<h2 id="mqttjspublisherts">MQTT.js 예제 (publisher.ts)</h2>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> mqtt <span class="hljs-keyword">from</span> <span class="hljs-string">\'mqtt\'</span>;\n\n<span class="hljs-keyword">import</span> { mqttClientOptions, mqttsClientOptions } <span class="hljs-keyword">from</span> <span class="hljs-string">\'./options\'</span>;\n\n<span class="hljs-keyword">const</span> client = mqtt.connect(mqttsClientOptions);\n\nclient.on(<span class="hljs-string">\'connect\'</span>, () =&gt; {\n    client.subscribe(<span class="hljs-string">\'presence\'</span>);\n    client.publish(<span class="hljs-string">\'presence\'</span>, <span class="hljs-string">\'Hello mqtt\'</span>);\n    client.end();\n});\n\nclient.on(<span class="hljs-string">\'error\'</span>, (error) =&gt; {\n    <span class="hljs-built_in">console</span>.log(error);\n});\n</code></pre>\n<h2 id="mqttjssubsriberts">MQTT.js 예제 (subsriber.ts)</h2>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> mqtt <span class="hljs-keyword">from</span> <span class="hljs-string">\'mqtt\'</span>;\n\n<span class="hljs-keyword">import</span> { mqttClientOptions, mqttsClientOptions } <span class="hljs-keyword">from</span> <span class="hljs-string">\'./options\'</span>;\n\n<span class="hljs-keyword">const</span> client = mqtt.connect(mqttsClientOptions);\n\nclient.on(<span class="hljs-string">\'connect\'</span>, () =&gt; {\n    client.subscribe(<span class="hljs-string">\'presence\'</span>);\n});\n\nclient.on(<span class="hljs-string">\'message\'</span>, (topic, message) =&gt; {\n    <span class="hljs-built_in">console</span>.log(topic, message);\n    client.end();\n});\n\nclient.on(<span class="hljs-string">\'error\'</span>, (error) =&gt; {\n    <span class="hljs-built_in">console</span>.log(error);\n});\n</code></pre>\n<h2 id="optionsts">옵션 (options.ts)</h2>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { IClientOptions } <span class="hljs-keyword">from</span> <span class="hljs-string">\'mqtt\'</span>;\n<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">\'fs\'</span>;\n\n<span class="hljs-keyword">export</span> interface ClientOptions extends IClientOptions {\n    passphrase?: string;\n    secureProtocol?: string;\n}\n\n<span class="hljs-keyword">export</span> interface MoscaLogger {\n    name?: string;\n    level?: number | string;\n}\n\n<span class="hljs-keyword">export</span> interface MoscaSecure {\n    port?: number;\n    keyPath?: string;\n    certPath?: string;\n}\n\n<span class="hljs-keyword">export</span> interface MoscaSettings {\n    <span class="hljs-attr">port</span>: number;\n    logger?: MoscaLogger;\n    secure?: MoscaSecure;\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mqttClientOptions: ClientOptions = {\n    <span class="hljs-attr">host</span>: <span class="hljs-string">\'localhost\'</span>,\n    <span class="hljs-attr">port</span>: <span class="hljs-number">1883</span>,\n    <span class="hljs-attr">protocol</span>: <span class="hljs-string">\'mqtt\'</span>,\n    <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>,\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mqttsClientOptions: ClientOptions = {\n    <span class="hljs-attr">host</span>: <span class="hljs-string">\'localhost\'</span>,\n    <span class="hljs-attr">port</span>: <span class="hljs-number">8443</span>,\n    <span class="hljs-attr">protocol</span>: <span class="hljs-string">\'mqtts\'</span>,\n    <span class="hljs-attr">protocolId</span>: <span class="hljs-string">\'MQIsdp\'</span>,\n    <span class="hljs-attr">protocolVersion</span>: <span class="hljs-number">3</span>,\n    <span class="hljs-attr">secureProtocol</span>: <span class="hljs-string">\'TLSv1_method\'</span>,\n    <span class="hljs-attr">reconnectPeriod</span>: <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>,\n    <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span>,\n    <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>,\n    <span class="hljs-attr">ca</span>: [fs.readFileSync(<span class="hljs-string">\'keystore/ca/ca.crt\'</span>)],\n    <span class="hljs-attr">key</span>: fs.readFileSync(<span class="hljs-string">\'keystore/client/client.key\'</span>),\n    <span class="hljs-attr">cert</span>: fs.readFileSync(<span class="hljs-string">\'keystore/client/client.crt\'</span>),\n};\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> moscaSettings: MoscaSettings = {\n    <span class="hljs-attr">port</span>: <span class="hljs-number">1883</span>,\n    <span class="hljs-attr">logger</span>: {\n        <span class="hljs-attr">name</span>: <span class="hljs-string">"secure"</span>,\n        <span class="hljs-attr">level</span>: <span class="hljs-number">40</span>,\n    },\n    <span class="hljs-attr">secure</span>: {\n        <span class="hljs-attr">port</span>: <span class="hljs-number">8443</span>,\n        <span class="hljs-attr">keyPath</span>: <span class="hljs-string">\'keystore/server/server.key\'</span>,\n        <span class="hljs-attr">certPath</span>: <span class="hljs-string">\'keystore/server/server.crt\'</span>,\n    },\n};\n</code></pre>\n<p>이제 문제는 Openssl 인데, Windows에서 Openssl을 사용하기 위해 2가지 방법이 있다.</p>\n<ol>\n<li>바이너리로 묵인 것을 다운로드 받기.</li>\n<li>소스를 받아서 직접 빌드하기.</li>\n</ol>\n<p>2번은 귀찮기 때문에, 1번을 찾아보고 다운로드 받았다.</p>\n<blockquote>\n  <p><a href="https://code.google.com/archive/p/openssl-for-windows/downloads">https://code.google.com/archive/p/openssl-for-windows/downloads</a></p>\n</blockquote>\n<p>다운로드 받고나면 압축을 푼 경로로 들어가 <code>bin</code>에서 <code>Windows Command Line</code>으로 직접 <code>openssl</code>명령어를 치면 되지만, 매번 할 수 없기 때문에 이것도 javascript로 <code>keygen</code>을 만들었다.</p>\n<p>프로젝트 경로로 맞춰 명령어를 실행하기 위해 openssl을 압축을 풀어 프로젝트 내부로 옮기고, 마찬가지로 openssl로 생성된 키와 인증서를 프로젝트 내부에 두기 위해 프로젝트 내에 <code>keystore</code> 폴더를 만든다.</p>\n<blockquote>\n  <p>Openssl로 생성해야되는 키와 인증서는 자체 서명된 CA, Server, Client가 모두 필요하기 때문에 keystore 하위 폴더로 ca, server, client를 만든다.</p>\n</blockquote>\n<p>위에 작성된 MQTT Broker, Client, Options를 포함하여 이렇게 생긴 폴더 구조가 생길 것이다.</p>\n<p><img src="/static/images/etc/openssl-project-directory.png" alt="project-directory" /></p>\n<p>그 다음 openssl 명령어를 실행하기 위한 Keygen을 작성한다.</p>\n<h2 id="keygenkeygents">Keygen (keygen.ts)</h2>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { execSync, ExecSyncOptions } <span class="hljs-keyword">from</span> <span class="hljs-string">\'child_process\'</span>;\n<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">\'path\'</span>;\n\ntype Status = <span class="hljs-string">\'all\'</span> | <span class="hljs-string">\'ca\'</span> | <span class="hljs-string">\'server\'</span> | <span class="hljs-string">\'client\'</span> | <span class="hljs-string">\'verify\'</span>;\n\n<span class="hljs-keyword">const</span> argsLength = process.argv.length;\n<span class="hljs-keyword">let</span> status: Status = <span class="hljs-string">\'all\'</span>;\n<span class="hljs-keyword">if</span> (argsLength &gt; <span class="hljs-number">2</span>) {\n    status = process.argv.slice(<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> Status;\n}\n\n<span class="hljs-keyword">const</span> opensslPath = <span class="hljs-string">\'openssl/bin/openssl\'</span>;\n<span class="hljs-keyword">const</span> opensslConfPath = <span class="hljs-string">`openssl/openssl.cnf`</span>;\n<span class="hljs-keyword">const</span> binPath = path.resolve(__dirname, opensslPath)\n<span class="hljs-keyword">const</span> confPath = path.resolve(__dirname, opensslConfPath);\n<span class="hljs-keyword">const</span> execSyncOption: ExecSyncOptions = {\n    <span class="hljs-attr">stdio</span>: <span class="hljs-string">\'inherit\'</span>,\n}\n\n<span class="hljs-comment">/**\n * Create CA\n */</span>\n<span class="hljs-keyword">const</span> caKeystorePath = <span class="hljs-string">\'keystore/ca\'</span>;\n<span class="hljs-keyword">const</span> caKeyPath = <span class="hljs-string">`<span class="hljs-subst">${caKeystorePath}</span>/ca.key`</span>;\n<span class="hljs-keyword">const</span> caCrtPath = <span class="hljs-string">`<span class="hljs-subst">${caKeystorePath}</span>/ca.crt`</span>;\n<span class="hljs-keyword">if</span> (status === <span class="hljs-string">\'all\'</span> || status === <span class="hljs-string">\'ca\'</span>) {\n    execSync(<span class="hljs-string">`<span class="hljs-subst">${binPath}</span> req -new -x509 -days 1024 -extensions v3_ca -keyout <span class="hljs-subst">${caKeyPath}</span> -out <span class="hljs-subst">${caCrtPath}</span> -config <span class="hljs-subst">${confPath}</span>`</span>, execSyncOption);\n}\n\n<span class="hljs-keyword">if</span> (status === <span class="hljs-string">\'verify\'</span>) {\n    execSync(<span class="hljs-string">`<span class="hljs-subst">${binPath}</span> x509 -text -in <span class="hljs-subst">${caCrtPath}</span>`</span>, execSyncOption)   ;\n}\n\n<span class="hljs-comment">/**\n * Create server key\n */</span>\n<span class="hljs-keyword">const</span> serverKeystorePath = <span class="hljs-string">\'keystore/server\'</span>;\n<span class="hljs-keyword">const</span> serverKeyPath = <span class="hljs-string">`<span class="hljs-subst">${serverKeystorePath}</span>/server.key`</span>;\n<span class="hljs-keyword">const</span> serverCsrPath =  <span class="hljs-string">`<span class="hljs-subst">${serverKeystorePath}</span>/server.csr`</span>;\n<span class="hljs-keyword">const</span> serverCrtPath = <span class="hljs-string">`<span class="hljs-subst">${serverKeystorePath}</span>/server.crt`</span>;\n<span class="hljs-keyword">if</span> (status === <span class="hljs-string">\'all\'</span> || status === <span class="hljs-string">\'server\'</span>) {\n    <span class="hljs-comment">// execSync(`${binPath} genrsa -des3 -out ${serverKeyPath} 2048`, execSyncOption);</span>\n    execSync(<span class="hljs-string">`<span class="hljs-subst">${binPath}</span> genrsa -out <span class="hljs-subst">${serverKeyPath}</span> 2048`</span>, execSyncOption);\n    execSync(<span class="hljs-string">`<span class="hljs-subst">${binPath}</span> req -out <span class="hljs-subst">${serverCsrPath}</span> -key <span class="hljs-subst">${serverKeyPath}</span> -new -config <span class="hljs-subst">${confPath}</span>`</span>, execSyncOption);\n    execSync(<span class="hljs-string">`<span class="hljs-subst">${binPath}</span> x509 -req -in <span class="hljs-subst">${serverCsrPath}</span> -CA <span class="hljs-subst">${caCrtPath}</span> -CAkey <span class="hljs-subst">${caKeyPath}</span> -CAcreateserial -out <span class="hljs-subst">${serverCrtPath}</span> -days 1024`</span>, execSyncOption);\n}\n\n<span class="hljs-comment">/**\n * Create client key\n */</span>\n<span class="hljs-keyword">const</span> clientKeystorePath = <span class="hljs-string">\'keystore/client\'</span>;\n<span class="hljs-keyword">const</span> clientKeyPath = <span class="hljs-string">`<span class="hljs-subst">${clientKeystorePath}</span>/client.key`</span>;\n<span class="hljs-keyword">const</span> clientCsrPath = <span class="hljs-string">`<span class="hljs-subst">${clientKeystorePath}</span>/client.csr`</span>;\n<span class="hljs-keyword">const</span> clientCrtPath = <span class="hljs-string">`<span class="hljs-subst">${clientKeystorePath}</span>/client.crt`</span>;\n<span class="hljs-keyword">if</span> (status === <span class="hljs-string">\'all\'</span> || status === <span class="hljs-string">\'client\'</span>) {\n    <span class="hljs-comment">// execSync(`${binPath} genrsa -des3 -out ${clientKeyPath} 2048`, execSyncOption);</span>\n    execSync(<span class="hljs-string">`<span class="hljs-subst">${binPath}</span> genrsa -out <span class="hljs-subst">${clientKeyPath}</span> 2048`</span>, execSyncOption);\n    execSync(<span class="hljs-string">`<span class="hljs-subst">${binPath}</span> req -out <span class="hljs-subst">${clientCsrPath}</span> -key <span class="hljs-subst">${clientKeyPath}</span> -new -config <span class="hljs-subst">${confPath}</span>`</span>, execSyncOption);\n    execSync(<span class="hljs-string">`<span class="hljs-subst">${binPath}</span> x509 -req -in <span class="hljs-subst">${clientCsrPath}</span> -CA <span class="hljs-subst">${caCrtPath}</span> -CAkey <span class="hljs-subst">${caKeyPath}</span> -CAcreateserial -out <span class="hljs-subst">${clientCrtPath}</span> -days 1024`</span>, execSyncOption);\n}\n</code></pre>\n<p>최종 적으로 npm script를 작성한다.</p>\n<h2 id="packagejsonscript">package.json script</h2>\n<p><img src="/static/images/etc/openssl-npm-script.png" alt="npm-script" /></p>\n<h2 id="tldr">TL;DR</h2>\n<p><code>npm run keygen</code>을 실행하면 CA, Server, Client 순으로 키와 인증서를 생성하기 위한 입력들이 나오고 질문에 맞춰 입력하면 되고, 최종적으로 keystore 폴더 하위에 ca, server, client에 키와 인증서들이 생성된다.</p>\n<p>그런 다음, <code>npm start</code>, <code>npm run sub</code>, <code>npm run pub</code>을 실행하여 메시지를 주고 받는 것을 확인해보면 된다.</p>\n<p><img src="/static/images/etc/openssl-mqtt-result.png" alt="mqtt-result" /></p>\n<p>아래 완성본을 받아서 테스트 해보면 된다.</p>\n<h2 id="">완성된 예제</h2>\n<p><a href="https://github.com/salgum1114/mqtt-ssl">https://github.com/salgum1114/mqtt-ssl</a></p>',preview:"회사에서 MQTT를 SSL/TLS로 테스트해야 하는 경우가 생겼는데, 기존에 나와있는 Eclipse Mosquitto로 하려다가 이왕 하는 김에\nJavascrpt로 MQTT Broker랑 Client (Pub, Sub)를 직접 구현해보기로 했다.\n\n전체적으로 MQTT Broker와 Client를 구현하기 위한 라이브러리들은 다음과 같다.\n\n * Mosca ...",title:"Windows에서 openssl로 인증서 생성하고 MQTT로 테스트하기",author:"salgum1114",date:"2019-05-20 10:09",tags:"openssl, typescript, mqtt",cover:"/static/images/covers/openssl.png",next:"/reactjs/2019-05-11-using-typescript-without-tsx",prev:"/nextjs/2019-05-20-nextjs-static-website-2"},"/reactjs/2019-05-11-using-typescript-without-tsx":{path:"/reactjs/2019-05-11-using-typescript-without-tsx",content:'<p>이번 글에서는 기존에 .js, .jsx 확장자로 작성된 React 컴포넌트에서 Typescript를 적용하여 컴포넌트 개발이나 사용 시에 타입을 확인할 수 있는 방법에 대해서 설명하려고 한다.</p>\n<p><code>Button.js</code> 컴포넌트로 간단한 예를 들어본다.</p>\n<pre><code class="hljs">src/\n    components/\n        button/\n            index<span class="hljs-selector-class">.js</span>\n            Button<span class="hljs-selector-class">.js</span>\n</code></pre>\n<p>구조로 컴포넌트가 작성되어 있다고한다면. 동일한 파일 경로에 <code>index.d.ts</code>를 만들자.</p>\n<pre><code class="hljs diff language-diff">src/\n    components/\n        button/\n            index.js\n            + index.d.ts\n            Button.js\n</code></pre>\n<p><code>index.d.ts</code>에는 <code>button</code>에 필요한 <code>Props</code>들을 Typescript로 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> interface ButtonProps extends React.HTMLAttributes&lt;HTMLButtonElement&gt; {}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">ButtonProps</span>&gt; </span>{}\n</code></pre>\n<blockquote>\n  <p>이 예제에서는 별다른 Props가 필요없이 Button 컴포넌트의 Typescript를 작성하는데 중점을 둔다.</p>\n</blockquote>\n<p>그럼 이제 <code>Button.js</code>를 작성한다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n\n<span class="hljs-comment">/**\n * @augments {Component&lt;import(\'.\').ButtonProps&gt;}\n */</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n    render() {\n        <span class="hljs-keyword">const</span> { children, ...other } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> {<span class="hljs-attr">...other</span>}&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;\n    }\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Button;\n</code></pre>\n<p>이렇게 작성된 <code>Button.js</code> 컴포넌트의 <code>this.props</code>의 deconstructing 부분에서 <code>ctrl + space</code>로 힌트를 쳐보면 다음과 같이 제공할 수 있는 props들이 힌트로 나오게된다.</p>\n<p><img src="/static/images/reactjs/define-typescript-hint.png" alt="define-typescript-hint" /></p>\n<p>이제 이 <code>Button.js</code> 컴포넌트를 가지고 다른 컴포넌트에서 사용해본다.</p>\n<p><img src="/static/images/reactjs/using-typescript-hint.png" alt="using-typescript-hint" /></p>\n<p>추가적으로 <code>functional component</code>에서는 다음처럼 작성할 수 있다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n\n<span class="hljs-comment">/**\n * @description\n * @param {import(\'.\').ButtonProps} props\n * @returns {React.ReactNode}\n */</span>\n<span class="hljs-keyword">const</span> Button = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {\n    <span class="hljs-keyword">const</span> { children, ...other } = props;\n    <span class="hljs-keyword">return</span> (\n        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> {<span class="hljs-attr">...other</span>}&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>\n    )\n}\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Button;\n</code></pre>\n<p>힌트도 똑같이 사용할 수 있다.</p>\n<p><img src="/static/images/reactjs/functional-using-typescript-hint.png" alt="functional-using-typescript-hint" /></p>',preview:"이번 글에서는 기존에 .js, .jsx 확장자로 작성된 React 컴포넌트에서 Typescript를 적용하여 컴포넌트 개발이나 사용 시에 타입을\n확인할 수 있는 방법에 대해서 설명하려고 한다.\n\nButton.js 컴포넌트로 간단한 예를 들어본다.\n\nsrc/\n    components/\n        button/\n            index.js\n   ...",title:"React에서 .tsx 없이 Typescript 사용하기",author:"salgum1114",date:"2019-05-11 19:50",tags:"react, typescript",cover:"/static/images/covers/react_typescript.png",next:"/nextjs/2019-05-06-nextjs-static-website-1",prev:"/etc/2019-05-20-using-openssl-in-windows"},"/nextjs/2019-05-06-nextjs-static-website-1":{path:"/nextjs/2019-05-06-nextjs-static-website-1",content:'<p><a href="https://nextjs.org/">Next.js</a>는 현재 가장 유명한 <a href="https://reactjs.org/">React</a>용 서버 사이드 렌더링 프레임워크이다.</p>\n<p>프레임워크로써 이해하기 쉬운 구조와 <a href="https://github.com/zeit/next.js/tree/canary/examples">수많은 예제</a>들, 그리고 다양한 플러그인들을 지원하고 있어 많은 사람들에게 사랑받고 있다.</p>\n<p>또한, Next.js는 <code>next export</code>라는 명령어로 <code>routing 경로</code>로 하여금 정적 웹사이트를 만들 수 있는 기능도 제공하고 있다.</p>\n<blockquote>\n  <p>Next.js의 최신 버전은 8.x.x인데 최신 버전에서는 export 기능이 제대로 동작하지 않으며, 현재 <code>next export</code> 기능은 7.x.x 버전에서 에러없이 잘 동작한다. <a href="https://github.com/zeit/next.js/issues/6251">[Static export failed when upgraded to v8.0.0 #6251]</a></p>\n</blockquote>\n<p>이 글은 Next.js의 export 기능을 사용하여 정적 웹사이트를 만드는 것에 대해서 설명하려고 한다.</p>\n<blockquote>\n  <p>이 글은 서버 사이드 렌더링이 아닌 정적 웹사이트를 만드는 것에 중점으로 설명한다.</p>\n</blockquote>\n<h2 id="nextjs">Next.js 기본 구조</h2>\n<p>Next.js의 기본 구조는 다음처럼 구성된다.</p>\n<pre><code class="hljs javascript language-javascript">pages/ <span class="hljs-comment">// HTML Document, Application Container, 각종 페이지 등을 작성한다.</span>\n    _document.js <span class="hljs-comment">// HTML Document.</span>\n    _app.js <span class="hljs-comment">// Application Container. 공통의 레이아웃을 작성한다.</span>\n    _error.js <span class="hljs-comment">// Error Page.</span>\n    index.js <span class="hljs-comment">// Root Page /로 시작되는 경로를 말한다.</span>\n    hello.js <span class="hljs-comment">// Hello Page /hello로 시작되는 경로를 말한다.</span>\n<span class="hljs-keyword">static</span>/ <span class="hljs-comment">// 정적 파일 (이미지, 파일 등)을 업로드 한다.</span>\nnext.config.js <span class="hljs-comment">// Next.js의 환경 설정 파일이다. 라우팅 설정, typescript, less 등의 webpack 플러그인을 설정한다.</span>\n</code></pre>\n<h2 id="_documentjs">_document.js</h2>\n<p>_document.js는 SPA에서 시작점이 되는 index.html이라고 생각하면 된다.</p>\n<blockquote>\n  <p>Custom Document를 만들때만 작성이 필요하며, 생략된 경우 Next.js가 기본 값을 사용한다.</p>\n</blockquote>\n<p>작성 예시는 다음과 같다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Document, { Head, Main, NextScript } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/document\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootDocument</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Document</span> </span>{\n    render() {\n        <span class="hljs-keyword">return</span> (\n            &lt;html&gt;\n                &lt;Head&gt;\n                    &lt;meta charSet="utf-8" /&gt;\n                    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" /&gt;\n                    &lt;meta name="description" content="Dev.log"/&gt;\n                    &lt;meta name="keywords" content="blog,react,antd,webpack,css,javascript" /&gt;\n                    &lt;link rel="manifest" href="/static/manifest.json" /&gt;\n                    &lt;link rel="shortcut icon" href="/static/favicon.ico" /&gt;\n                    &lt;link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/notosanskr.css" /&gt;\n                    &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css" /&gt;\n                    &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/railscasts.min.css" /&gt;\n                &lt;/Head&gt;\n                &lt;body&gt;\n                    &lt;Main /&gt;\n                    &lt;NextScript /&gt;\n                &lt;/body&gt;\n            &lt;/html&gt;\n        );\n    }\n}\n</code></pre>\n<p>_document.js에서 React와 같은 동작을 수행할 수 있을 것처럼 보이지만 <code>React Lifecycle</code>과 <code>Data Fetching</code>이 불가능하다.</p>\n<p><img src="/static/images/nextjs/document-app-differences.png" alt="document-app-differences" /></p>\n<p>React에서는 <code>&lt;div id="root" /&gt;</code>처럼 React 컴포넌트가 마운트 되는 최초 요소를 작성하게 된다. 하지만 Next.js에서는 따로 작성할 필요 없이, <code>Main</code>과 <code>NextScript</code> 클래스에 내장 되어 있다.</p>\n<p><code>Main</code>과 <code>NextScript</code>의 자세한 설명은 이 글을 참조한다. <a href="https://stackoverflow.com/questions/52083848/nextjs-main-and-nextscript">NextJS: Main and Nextscript</a></p>\n<h2 id="_appjs">_app.js</h2>\n<p>React에서 대부분 App.js이라는 이름으로 공통의 레이아웃을 작성하듯이 Next.js에서는 Application의 공통 레이아웃을 _app.js에서 작성할 수 있다.</p>\n<blockquote>\n  <p>생략된 경우 Next.js가 기본 값을 사용한다.</p>\n</blockquote>\n<p>작성 예시는 다음과 같다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> App, { Container } <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/app\'</span>;\n<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">\'nprogress\'</span>;\n<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">\'next/router\'</span>;\n<span class="hljs-keyword">import</span> Helmet <span class="hljs-keyword">from</span> <span class="hljs-string">\'react-helmet\'</span>;\n<span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">\'moment\'</span>;\n\n<span class="hljs-keyword">import</span> Layout <span class="hljs-keyword">from</span> <span class="hljs-string">\'../components/Layout\'</span>;\n<span class="hljs-keyword">import</span> <span class="hljs-string">\'../styles/index.less\'</span>;\n\nmoment.locale(<span class="hljs-string">\'ko\'</span>);\n\nRouter.events.on(<span class="hljs-string">\'routeChangeStart\'</span>, (url) =&gt; NProgress.start());\nRouter.events.on(<span class="hljs-string">\'routeChangeComplete\'</span>, () =&gt; NProgress.done());\nRouter.events.on(<span class="hljs-string">\'routeChangeError\'</span>, () =&gt; NProgress.done());\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>{\n    render() {\n        <span class="hljs-keyword">const</span> { Component, ...other } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> (\n            &lt;Container&gt;\n                &lt;Helmet title="Dev.log" /&gt;\n                &lt;Layout {...other} {...this.state}&gt;\n                    &lt;Component {...other} {...this.state} /&gt;\n                &lt;/Layout&gt;\n            &lt;/Container&gt;\n        );\n    }\n}\n</code></pre>\n<p>이곳에서 ComponentDidCatch로 Error Handling을 한다던지, Routing이 되었을 때의 Progressing 처리, 스타일 시트 Import 등을 작성한다.</p>\n<h2 id="_errorjs">_error.js</h2>\n<p>Error 처리를 공통으로 하고자 할 때, 공통적으로 사용할 수 있는 Error Page를 작성할 수 있다.</p>\n<blockquote>\n  <p>생략된 경우 Next.js가 기본 값을 사용한다.</p>\n</blockquote>\n<p>작성 예시는 다음과 같다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n\n<span class="hljs-keyword">import</span> ErrorPage <span class="hljs-keyword">from</span> <span class="hljs-string">\'../components/ErrorPage\'</span>;\n\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n    render() {\n        <span class="hljs-keyword">const</span> { statusCode } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorPage</span> <span class="hljs-attr">statusCode</span>=<span class="hljs-string">{statusCode}</span> /&gt;</span>;\n    }\n}\n</span></code></pre>\n<h2 id="nextconfigjs">next.config.js</h2>\n<p>webpack plugin들과 Next.js의 라우팅 설정을 작성한다.</p>\n<p>작성 예시는 다음과 같다.</p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> withLess = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'@zeit/next-less\'</span>);\n<span class="hljs-keyword">const</span> withTypescript = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'@zeit/next-typescript\'</span>);\n\n<span class="hljs-comment">// fix: prevents error when .less files are required by node</span>\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">require</span> !== <span class="hljs-string">\'undefined\'</span>) {\n    <span class="hljs-built_in">require</span>.extensions[<span class="hljs-string">\'.less\'</span>] = <span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> {}\n}\n\n<span class="hljs-built_in">module</span>.exports = withTypescript(withLess({\n    <span class="hljs-attr">lessLoaderOptions</span>: {\n        <span class="hljs-attr">javascriptEnabled</span>: <span class="hljs-literal">true</span>,\n    },\n    <span class="hljs-attr">exportPathMap</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">return</span> {\n        <span class="hljs-string">\'/\'</span>: { <span class="hljs-attr">page</span>: <span class="hljs-string">\'/\'</span> },\n        <span class="hljs-string">\'/about\'</span>: { <span class="hljs-attr">page</span>: <span class="hljs-string">\'/about\'</span> },\n        <span class="hljs-string">\'/readme.md\'</span>: { <span class="hljs-attr">page</span>: <span class="hljs-string">\'/readme\'</span> },\n        <span class="hljs-string">\'/p/hello-nextjs\'</span>: { <span class="hljs-attr">page</span>: <span class="hljs-string">\'/post\'</span>, <span class="hljs-attr">query</span>: { <span class="hljs-attr">title</span>: <span class="hljs-string">\'hello-nextjs\'</span> } },\n        <span class="hljs-string">\'/p/learn-nextjs\'</span>: { <span class="hljs-attr">page</span>: <span class="hljs-string">\'/post\'</span>, <span class="hljs-attr">query</span>: { <span class="hljs-attr">title</span>: <span class="hljs-string">\'learn-nextjs\'</span> } },\n        <span class="hljs-string">\'/p/deploy-nextjs\'</span>: { <span class="hljs-attr">page</span>: <span class="hljs-string">\'/post\'</span>, <span class="hljs-attr">query</span>: { <span class="hljs-attr">title</span>: <span class="hljs-string">\'deploy-nextjs\'</span> } }\n    },\n}));\n</code></pre>\n<p>Next.js와 관련된 webpack plugin들은 <code>@zeit/next</code> Prefix로 패키지를 제공하고 있으며, 사용할 때는 <code>with</code> prefix로 선언해서 사용한다.</p>\n<p><code>exportPathMap</code>이 Next.js의 라우팅 경로이다.</p>\n<h3 id="nextjs-1">Next.js로 정적 웹사이트 만들기 목차</h3>\n<ul>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-06-nextjs-static-website-1/">Next.js로 정적 웹사이트 만들기 - 1. Next.js 구조</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-20-nextjs-static-website-2/">Next.js로 정적 웹사이트 만들기 - 2. 프로젝트 구성</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-21-nextjs-static-website-3/">Next.js로 정적 웹사이트 만들기 - 3. 레이아웃</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-24-nextjs-static-website-4/">Next.js로 정적 웹사이트 만들기 - 4. Routing 사용하기</a></li>\n<li><a href="https://salgum1114.github.io/nextjs/2019-05-28-nextjs-static-website-5/">Next.js로 정적 웹사이트 만들기 - 5. Material UI 적용하기</a></li>\n</ul>',preview:"Next.js는 현재 가장 유명한 React용 서버 사이드 렌더링 프레임워크이다.\n\n프레임워크로써 이해하기 쉬운 구조와 수많은 예제들, 그리고 다양한 플러그인들을 지원하고 있어 많은 사람들에게 사랑받고 있다.\n\n또한, Next.js는 next export라는 명령어로 routing 경로로 하여금 정적 웹사이트를 만들 수 있는 기능도 제공하고 있다.\n\n>  ...",title:"Next.js로 정적 웹사이트 만들기 - 1. Next.js 구조",author:"salgum1114",date:"2019-05-06 19:50",tags:"react, nextjs, website",cover:"/static/images/covers/nextjs.png",next:"/reactjs/2019-05-03-medium-zoom",prev:"/reactjs/2019-05-11-using-typescript-without-tsx"},"/reactjs/2019-05-03-medium-zoom":{path:"/reactjs/2019-05-03-medium-zoom",content:'<p>평소 <a href="https://medium.com/">Medium</a>에서 개발 포스팅을 찾아보는 편인데, 글에서 이미지를 클릭했을 때, 줌이 되는 기능이 이뻐보여서 내 개발 블로그에도 적용하고 싶어 비슷한 라이브러리들이 있나 찾아보게 되었다.</p>\n<p>우선 이 블로그가 React로 개발했으니 React에서 사용할 수 있는 라이브러리를 찾아보니 <a href="https://github.com/rpearce/react-medium-image-zoom">react-medium-image-zoom</a>이 있었다. 하지만 React로 작성해야 하기 때문에, 마크다운이 HTML로 번역된 상태에서는 사용이 불가능해 보인다.</p>\n<p>이와는 다르게 querySelector로 <code>&lt;img&gt;</code>요소들을 파라미터로 전달하기만 하면 사용할 수 있는 <a href="https://github.com/francoischalifour/medium-zoom">medium-zoom</a> 라이브러리가 있었다.</p>\n<blockquote>\n  <p><a href="https://github.com/francoischalifour/medium-zoom">medium-zoom</a>에 대한 사용 방법은 github에 잘 나와있고 playground로 데모를 확인할 수 있다.</p>\n</blockquote>\n<h4 id="mediumzoom">medium-zoom 사용 방법</h4>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// CSS selector</span>\nmediumZoom(<span class="hljs-string">\'[data-zoomable]\'</span>);\n\n<span class="hljs-comment">// HTMLElement</span>\nmediumZoom(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'#cover\'</span>));\n\n<span class="hljs-comment">// NodeList</span>\nmediumZoom(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">\'[data-zoomable]\'</span>));\n\n<span class="hljs-comment">// Array</span>\n<span class="hljs-keyword">const</span> images = [\n  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'#cover\'</span>),\n  ...document.querySelectorAll(<span class="hljs-string">\'[data-zoomable]\'</span>),\n];\n\nmediumZoom(images);\n</code></pre>\n<blockquote>\n  <p>추가적인 옵션이 있는데 <a href="https://github.com/francoischalifour/medium-zoom">medium-zoom github</a>에서 확인하자.</p>\n</blockquote>\n<p>React에서 사용할 때는 다음 처럼 사용하면 된다.</p>\n<h4 id="reactmediumzoom">React에서 medium-zoom 사용 방법</h4>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> mediumZoom <span class="hljs-keyword">from</span> <span class="hljs-string">\'medium-zoom\'</span>;\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediumZoomExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n    componentDidMount() {\n        <span class="hljs-keyword">const</span> images = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">\'.example-container img\'</span>);\n        mediumZoom(images);\n    }\n\n    render() {\n        <span class="hljs-keyword">return</span> (\n            &lt;div className="example-container"&gt;\n                &lt;img src="/test.png" /&gt;\n                &lt;img src="/test2.png" /&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n</code></pre>\n<p>블로그에 적용된 결과.</p>\n<p><img src="/static/images/reactjs/medium-zoom.gif" alt="medium-zoom-apply" /></p>',preview:"평소 Medium에서 개발 포스팅을 찾아보는 편인데, 글에서 이미지를 클릭했을 때, 줌이 되는 기능이 이뻐보여서 내 개발 블로그에도 적용하고\n싶어 비슷한 라이브러리들이 있나 찾아보게 되었다.\n\n우선 이 블로그가 React로 개발했으니 React에서 사용할 수 있는 라이브러리를 찾아보니 react-medium-image-zoom이\n있었다. 하지만 React로...",title:"medium-zoom 적용하기",author:"salgum1114",date:"2019-05-03 12:46",tags:"react, medium-zoom",cover:"/static/images/covers/medium-zoom.gif",next:"/css/2019-04-30-overscroll-behavior-contain",prev:"/nextjs/2019-05-06-nextjs-static-website-1"},"/css/2019-04-30-overscroll-behavior-contain":{path:"/css/2019-04-30-overscroll-behavior-contain",content:'<p>웹에서 스크롤을 다루다보면 항상 마주치는 문제 중 하나가 <strong>스크롤 체이닝</strong>이다.</p>\n<p>다음 예제를 보자.</p>\n<iframe height="465" style="width: 100%;" scrolling="no" title="overscroll-behavior: cotain before" src="//codepen.io/salgum1114/embed/MRMaWX/?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/salgum1114/pen/MRMaWX/\'>overscroll-behavior: cotain before</a> by Sung Gyun Oh\n  (<a href=\'https://codepen.io/salgum1114\'>@salgum1114</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<p>위 예제에서 Box-1의 스크롤이 끝에 도달하게 되면 상위 요소인 App의 스크롤이 시작이된다.</p>\n<p>심지어 App의 스크롤이 끝에 도달하게 되면 이 포스팅의 본문까지 스크롤이 시작되게 된다.</p>\n<p>이러한 현상을 <strong>스크롤 체이닝</strong>이라고 불리며, 구글 개발자 사이트의 <a href="https://developers.google.com/web/updates/2017/11/overscroll-behavior">Take control of your scroll: customizing pull-to-refresh and overflow effects</a>에 설명이 잘 되어있다.</p>\n<p>여기서 설명하길 CSS의 <strong>overscroll-behavior</strong>속성을 사용하여 스크롤로 일어날 수 있는 다양한 현상을 조절할 수 있다고 한다.</p>\n<blockquote>\n  <p>단, 이 속성은 본문의 첫번째 단락에 주의로 크롬 63버전 이상부터 지원하며, 다른 브라우저는 고려 중이라고 작성되어있다.</p>\n</blockquote>\n<h4 id="">브라우저 호환성 참고</h4>\n<p><img src="/static/images/css/overscroll-behavior-support.png" alt="overscroll-behavior-support" /></p>\n<p>이제 예제에 <strong>overscroll-behavior</strong> 속성을 적용하여 스크롤 체이닝 현상을 피해보자.</p>\n<blockquote>\n  <p>overscroll-behavior 속성은 x, y도 따로 다룰 수 있다.</p>\n</blockquote>\n<iframe height="465" style="width: 100%;" scrolling="no" title="overscroll-behavior: cotain after" src="//codepen.io/salgum1114/embed/EJBVvq/?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/salgum1114/pen/EJBVvq/\'>overscroll-behavior: cotain after</a> by Sung Gyun Oh\n  (<a href=\'https://codepen.io/salgum1114\'>@salgum1114</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<p>Box-1에서 스크롤을 끝까지 도달시켜보면 이전과 다르게 상위 요소인 App의 스크롤이 시작되지 않으면서 스크롤 체이닝을 피하게 된다.</p>\n<h4 id="-1">참고 사이트</h4>\n<ul>\n<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/overscroll-behavior">MDN: overscroll-behavior</a></li>\n<li><a href="https://developers.google.com/web/updates/2017/11/overscroll-behavior">Google Developers - Take control of your scroll: customizing pull-to-refresh and overflow effects</a></li>\n</ul>',preview:"웹에서 스크롤을 다루다보면 항상 마주치는 문제 중 하나가 스크롤 체이닝이다.\n\n다음 예제를 보자.\n\nSee the Pen overscroll-behavior: cotain before by Sung Gyun Oh (@salgum1114) on \nCodePen.위 예제에서 Box-1의 스크롤이 끝에 도달하게 되면 상위 요소인 App의 스크롤이 시작이된다.\n\n...",title:"overscroll-behavior: contain 속성 사용하기",author:"salgum1114",date:"2019-04-30 19:28",tags:"css, overscroll-behavior",cover:"/static/images/covers/css.png",next:"/css/2019-04-28-scroll-behavior-smooth",prev:"/reactjs/2019-05-03-medium-zoom"},"/css/2019-04-28-scroll-behavior-smooth":{path:"/css/2019-04-28-scroll-behavior-smooth",content:'<p>블로그에 부드러운 스크롤링을 위해서 CSS의 <code>scroll-behavior</code>를 활용해본다.</p>\n<p>우선, <code>scroll-behavior</code>이 뭔지 알아보자.</p>\n<blockquote>\n  <p><a href="https://www.w3schools.com/cssref/pr_scroll-behavior.asp">w3school: CSS scroll-behavior Property</a>에 아주 잘 나와있다.</p>\n</blockquote>\n<p>사용 방법은 아주 간단하다. 아래 코드를 확인해보자.</p>\n<h4 id="scrollbehaviorsmooth">scroll-behavior: smooth 적용 전</h4>\n<iframe height="465" style="width: 100%;" scrolling="no" title="scroll-behavior: smooth before" src="//codepen.io/salgum1114/embed/ZZPBjZ/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/salgum1114/pen/ZZPBjZ/\'>scroll-behavior: smooth before</a> by Sung Gyun Oh\n  (<a href=\'https://codepen.io/salgum1114\'>@salgum1114</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<h4 id="scrollbehaviorsmooth-1">scroll-behavior: smooth 적용 후</h4>\n<iframe height="465" style="width: 100%;" scrolling="no" title="scroll-behavior: smooth" src="//codepen.io/salgum1114/embed/axMmrP/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/salgum1114/pen/axMmrP/\'>scroll-behavior: smooth</a> by Sung Gyun Oh\n  (<a href=\'https://codepen.io/salgum1114\'>@salgum1114</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<blockquote>\n  <p>speed를 조절할 수 있는지는 모르겠다.</p>\n</blockquote>\n<p>이제 블로그에 적용된 것을 확인해보자.</p>\n<h4 id="bottom">Bottom</h4>\n<p><a href="#top">아래로 이동</a>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br /></p>\n<h4 id="top">Top</h4>\n<p><a href="#bottom">위로 이동</a></p>',preview:"블로그에 부드러운 스크롤링을 위해서 CSS의 scroll-behavior를 활용해본다.\n\n우선, scroll-behavior이 뭔지 알아보자.\n\n>  w3school: CSS scroll-behavior Property에 아주 잘 나와있다.\n\n\n사용 방법은 아주 간단하다. 아래 코드를 확인해보자.\n\nSCROLL-BEHAVIOR: SMOOTH 적용 전\nSee...",title:"scroll-behavior: smooth 속성 사용하기",author:"salgum1114",date:"2019-04-28 16:28",tags:"css, scroll-behavior",cover:"/static/images/covers/css.png",next:"/reactjs/2019-04-25-back-top-component",prev:"/css/2019-04-30-overscroll-behavior-contain"},"/reactjs/2019-04-25-back-top-component":{path:"/reactjs/2019-04-25-back-top-component",content:'<p>블로그 개발 중 스크롤이 되었을 때, 상위로 이동시키는 <code>BackTop</code>을 적용하기 위해 <a href="https://ant.design/components/back-top/">Ant.Design의 BackTop 컴포넌트</a>를 사용하려고 했다.</p>\n<p>하지만 <a href="https://ant.design/components/back-top/">Ant.Design의 BackTop 컴포넌트</a>를 적용해보니 잘 안된다. 따라서 직접 <code>BackTop</code> 컴포넌트를 구현하기로 결정했다.</p>\n<blockquote>\n  <p>Ant.Design 홈페이지에선 잘 동작한다.</p>\n</blockquote>\n<p>구현 코드는 다음과 같다.</p>\n<p><strong>BackTop.tsx</strong></p>\n<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> { Icon, Button } <span class="hljs-keyword">from</span> <span class="hljs-string">\'antd\'</span>;\n<span class="hljs-keyword">import</span> throttle <span class="hljs-keyword">from</span> <span class="hljs-string">\'lodash/throttle\'</span>;\n\ninterface IProps {\n    scrollStep?: number;\n    delayMs: number;\n    target: string;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackTop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span>&lt;<span class="hljs-title">IProps</span>&gt; </span>{\n    private content: Element;\n    private timeoutId: NodeJS.Timeout;\n    private intervalId: NodeJS.Timeout;\n\n    <span class="hljs-keyword">static</span> defaultProps = {\n        <span class="hljs-attr">scrollStep</span>: <span class="hljs-number">50</span>,\n        <span class="hljs-attr">delayMs</span>: <span class="hljs-number">16</span>,\n    }\n\n    componentDidMount() {\n        <span class="hljs-keyword">const</span> { target } = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">if</span> (target) {\n            <span class="hljs-keyword">this</span>.content = <span class="hljs-built_in">document</span>.querySelector(target);\n            <span class="hljs-keyword">this</span>.content.addEventListener(<span class="hljs-string">\'scroll\'</span>, <span class="hljs-keyword">this</span>.onScroll);\n        }\n    }\n\n    onScroll = throttle(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {\n        <span class="hljs-keyword">if</span> (e.target.scrollTop &gt;= <span class="hljs-number">64</span>) {\n            <span class="hljs-keyword">const</span> backtop = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'.backtop\'</span>);\n            <span class="hljs-keyword">if</span> (backtop) {\n                content.classList.add(<span class="hljs-string">\'visible\'</span>);\n            }\n            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.timeoutId) {\n                clearTimeout(<span class="hljs-keyword">this</span>.timeoutId);\n            }\n            <span class="hljs-keyword">this</span>.timeoutId = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n                <span class="hljs-keyword">if</span> (backtop) {\n                    backtop.classList.remove(<span class="hljs-string">\'visible\'</span>);\n                }\n            }, <span class="hljs-number">1500</span>);\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">const</span> backtop = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">\'.backtop\'</span>);\n            <span class="hljs-keyword">if</span> (backtop) {\n                backtop.classList.remove(<span class="hljs-string">\'visible\'</span>);\n            }\n        }\n    }, <span class="hljs-number">200</span>);\n\n    scrollStep = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.content.scrollTop === <span class="hljs-number">0</span>) {\n            clearInterval(<span class="hljs-keyword">this</span>.intervalId);\n        }\n        <span class="hljs-keyword">this</span>.content.scrollTo(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.content.scrollTop - <span class="hljs-keyword">this</span>.props.scrollStep);\n    }\n\n    scrollToTop = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.content &amp;&amp; <span class="hljs-keyword">this</span>.props.target) {\n            <span class="hljs-keyword">this</span>.intervalId = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n                <span class="hljs-keyword">this</span>.scrollStep();\n            }, <span class="hljs-keyword">this</span>.props.delayMs);\n        }\n    }\n\n    render() {\n        <span class="hljs-keyword">return</span> (\n            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"backtop"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">"circle"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.scrollToTop}</span>&gt;</span>\n                <span class="hljs-tag">&lt;<span class="hljs-name">Icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"to-top"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">fontSize:</span> \'<span class="hljs-attr">1.25rem</span>\' }} /&gt;</span>\n            <span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>\n        );\n    }\n}\n\nexport default BackTop;\n</span></code></pre>\n<p><strong>backtop.less</strong></p>\n<pre><code class="hljs less language-less"><span class="hljs-selector-class">.backtop</span> {\n    <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;\n    <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;\n    <span class="hljs-attribute">position</span>: fixed;\n    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">16px</span>;\n    <span class="hljs-attribute">right</span>: <span class="hljs-number">16px</span>;\n    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.25s</span> ease-in;\n    <span class="hljs-attribute">transform</span>: translateY(<span class="hljs-number">10px</span>);\n    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;\n    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-class">.visible</span> {\n        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;\n        <span class="hljs-attribute">transform</span>: translateY(<span class="hljs-number">0</span>);\n    }\n}\n</code></pre>\n<p><strong>BackTop이 적용된 화면이다.</strong></p>\n<p><img src="/static/images/css/blog-backtop-apply.gif" alt="blog-backtop-apply" /></p>',preview:"블로그 개발 중 스크롤이 되었을 때, 상위로 이동시키는 BackTop을 적용하기 위해 Ant.Design의 BackTop 컴포넌트를 사용하려고\n했다.\n\n하지만 Ant.Design의 BackTop 컴포넌트를 적용해보니 잘 안된다. 따라서 직접 BackTop 컴포넌트를 구현하기로 결정했다.\n\n>  Ant.Design 홈페이지에선 잘 동작한다.\n\n\n구현 코드는 ...",title:"BackTop 컴포넌트 만들기",author:"salgum1114",date:"2019-04-25 18:23",tags:"react, component, backtop",cover:"/static/images/covers/react.png",next:"/webpack/2019-04-22-uglifyjs-to-terser",prev:"/css/2019-04-28-scroll-behavior-smooth"},"/webpack/2019-04-22-uglifyjs-to-terser":{path:"/webpack/2019-04-22-uglifyjs-to-terser",content:'<p>최근 <a href="https://github.com/salgum1114/react-design-editor">React Design Editor</a>에 빌드 실패 관련 이슈가 올라왔다.</p>\n<p>내용인 즉슨, <code>production</code>으로 빌드시 UglifyJsPlugin에서 <code>Unexpected token: keyword «const»</code>라는 오류가 발생하여 계속해서 빌드에 실패한다는 것이다.</p>\n<p><a href="https://github.com/salgum1114/react-design-editor/issues/101">[Bug] Not able to create build for the application #101</a></p>\n<pre><code class="hljs shell language-shell"><span class="hljs-meta">react-design-editor&gt;</span><span class="bash"> npm run build</span>\n\nreact-design-editor@0.0.1 build D:\\Projects\\VirtualTutor\\vt-bkp\\react-design-editor\nwebpack -p --config webpack.prod.js\n\nclean-webpack-plugin: D:\\Projects\\VirtualTutor\\vt-bkp\\react-design-editor\\public\\js has been removed.\nHash: 6f635a8eff2d04c3d630\nVersion: webpack 4.30.0\nTime: 28583ms\nBuilt at: 04/19/2019 4:12:58 PM\n129 assets\nEntrypoint app = js/1.784bfc366d4d89f7.js js/app.359b7dab68a97eb6.js\n[17] (webpack)/buildin/harmony-module.js 573 bytes {1} [built]\n[45] ./node_modules/rc-animate/es/Animate.js + 3 modules 17.1 KiB {1} [built]\n| 4 modules\n[65] (webpack)/buildin/global.js 472 bytes {1} [built]\n[193] (webpack)/buildin/module.js 497 bytes {1} [built]\n[557] jsdom (ignored) 15 bytes {0} {1} [built]\n[558] jsdom/lib/jsdom/living/generated/utils (ignored) 15 bytes {0} {1} [built]\n[559] jsdom/lib/jsdom/utils (ignored) 15 bytes {0} {1} [built]\n[560] xmldom (ignored) 15 bytes {0} {1} [built]\n[765] ./src/containers/App.js 3.46 KiB {0} [built]\n[845] ./src/registerServiceWorker.js 6.72 KiB {0} [built]\n[846] ./src/i18n/index.js 53 bytes {0} [built]\n[1134] multi @babel/polyfill ./src/index.js 40 bytes {0} [built]\n[1310] ./src/index.js 1.72 KiB {0} [built]\n[1705] ./node_modules/antd/es/index.js + 303 modules 1.55 MiB {1} [built]\n| 304 modules\n[1708] multi react react-dom lodash fabric antd 76 bytes {1} [built]\n+ 1694 hidden modules\n\nERROR in js/1.784bfc366d4d89f7.js from UglifyJs\nUnexpected token: keyword «const» [./node_modules/@babel/polyfill/lib/index.js:6,0][js/1.784bfc366d4d89f7.js:185555,2]\nChild html-webpack-plugin for "index.html":\n1 asset\nEntrypoint undefined = index.html\n[2] (webpack)/buildin/global.js 472 bytes {0} [built]\n[3] (webpack)/buildin/module.js 497 bytes {0} [built]\n+ 2 hidden modules\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 2\nnpm ERR! react-design-editor@0.0.1 build: webpack -p --config webpack.prod.js\nnpm ERR! Exit status 2\nnpm ERR!\nnpm ERR! Failed at the react-design-editor@0.0.1 build script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\n\nnpm ERR! A complete log of this run can be found in:\nnpm ERR! C:\\Users\\manish.kumar.GATEWAYGROUP\\AppData\\Roaming\\npm-cache_logs\\2019-04-19T10_42_59_421Z-debug.log\n</code></pre>\n<p><code>babel polyfill</code>시 뭔가 충돌나는 것 같아 나와 비슷한 사례를 찾기 위해 구글링을 해본다.</p>\n<p>최근 이슈는 아니지만, 비슷한 사례가 많이 나온다.</p>\n<p><img src="/static/images/webpack/uglifyjs-const-issue-search.png" alt="uglify-js-issue" /></p>\n<p><a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin/issues/362">첫번째 이슈</a> 사이트에서 내용을 읽어보니, UglifyJsPlugin 버전 2부터 uglify-es가 버려졌으니 es6를 사용하고 싶으면 terser-webpack-plugin을 사용하라는 내용인것 같다.</p>\n<p>실제로 확인해보니 <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin/releases/tag/v2.0.0">uglifyjs-webpack-plugin 릴리즈 태그 v2.0 Change Log</a>에 내용이 있었다.</p>\n<p><img src="/static/images/webpack/uglifyjs-v2-change-log.png" alt="uglify-js-2.0" /></p>\n<blockquote>\n  <p>근데 terser가 무슨 뜻이지? naver 사전에서는 간결한 이라고 나온다.</p>\n</blockquote>\n<p>아무튼 <a href="https://github.com/salgum1114/react-design-editor/issues/101">이슈</a> 해결을 위해 <code>uglifyjs-webpack-plugin</code>에서 <code>terser-webpack-plugin</code>으로 변경을 시도해본다.</p>\n<p>우선 변경을 위해 <a href="https://github.com/webpack-contrib/terser-webpack-plugin">terser-webpack-plugin</a> github에서 사용방법을 찾아봤다.</p>\n<p>찾아보니 terser-webpack-plugin과 uglifyjs-webpack-plugin의 사용법이 크게 다르지 않았다.</p>\n<h3 id="uglifyjswebpackplugin">기존 uglifyjs-webpack-plugin 옵션</h3>\n<pre><code class="hljs javascript language-javascript">optimization: {\n    <span class="hljs-attr">minimizer</span>: [\n        <span class="hljs-keyword">new</span> UglifyJsPlugin({\n            <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>,\n            <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,\n            <span class="hljs-attr">uglifyOptions</span>: {\n                <span class="hljs-attr">warnings</span>: <span class="hljs-literal">false</span>,\n                <span class="hljs-attr">compress</span>: {\n                    <span class="hljs-attr">warnings</span>: <span class="hljs-literal">false</span>,\n                    <span class="hljs-attr">unused</span>: <span class="hljs-literal">true</span>,\n                },\n                <span class="hljs-attr">ecma</span>: <span class="hljs-number">6</span>,\n                <span class="hljs-attr">mangle</span>: <span class="hljs-literal">true</span>,\n                <span class="hljs-attr">unused</span>: <span class="hljs-literal">true</span>,\n            },\n            <span class="hljs-attr">sourceMap</span>: <span class="hljs-literal">true</span>,\n        }),\n    ],\n},\n</code></pre>\n<h3 id="terserwebpackplugin">변경할 terser-webpack-plugin 옵션</h3>\n<pre><code class="hljs javascript language-javascript">optimization: {\n    <span class="hljs-attr">minimizer</span>: [\n        <span class="hljs-keyword">new</span> TerserPlugin({\n            <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>,\n            <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,\n            <span class="hljs-attr">terserOptions</span>: {\n                <span class="hljs-attr">warnings</span>: <span class="hljs-literal">false</span>,\n                <span class="hljs-attr">compress</span>: {\n                    <span class="hljs-attr">warnings</span>: <span class="hljs-literal">false</span>,\n                    <span class="hljs-attr">unused</span>: <span class="hljs-literal">true</span>,\n                },\n                <span class="hljs-attr">ecma</span>: <span class="hljs-number">6</span>,\n                <span class="hljs-attr">mangle</span>: <span class="hljs-literal">true</span>,\n                <span class="hljs-attr">unused</span>: <span class="hljs-literal">true</span>,\n            },\n            <span class="hljs-attr">sourceMap</span>: <span class="hljs-literal">true</span>,\n        }),\n    ],\n},\n</code></pre>\n<p>기본적인 옵션은 같고, <code>uglifyOptions</code>에서 <code>terserOptions</code>으로 변경하면 되는 것 같다.</p>\n<p>이제 변경된 옵션으로 <a href="https://github.com/salgum1114/react-design-editor">React Design Editor</a>를 빌드해본다.</p>\n<p><img src="/static/images/webpack/terser-webpack-plugin-build.png" alt="terser-webpack-plugin-build" /></p>\n<h4 id="">성공한것 같다.</h4>\n<p><em>마지막으로 요청자에게 이슈를 해결했다는 코멘트를 달아주는것으로 마무리한다.</em></p>',preview:"최근 React Design Editor에 빌드 실패 관련 이슈가 올라왔다.\n\n내용인 즉슨, production으로 빌드시 UglifyJsPlugin에서 Unexpected token: keyword «const»라는\n오류가 발생하여 계속해서 빌드에 실패한다는 것이다.\n\n[Bug] Not able to create build for the applicati...",title:"UglifyJsPlugin const 오류 해결 방법",author:"salgum1114",date:"2019-04-22 21:05",tags:"webpack, uglifyjs, terser-webpack-plugin",cover:"/static/images/covers/webpack.png",next:null,prev:"/reactjs/2019-04-25-back-top-component"}}}}]);